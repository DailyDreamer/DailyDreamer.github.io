[{
	"uri": "https://dailydreamer.me/post/2017-08-07-a-new-kind-of-science-2/",
	"title": "一种新科学(2)",
	"tags": ["读书笔记", "科学"],
	"description": "",
	"content": " 摘要 本文是我在上次挖坑之后读完沃尔夫勒姆的著作《一种新科学》后的一些感想。 《一种新科学》是一本贡献和争议并存的书籍，它深入的探讨了元胞自动机的演化，也即计算复杂性而非传统科学方法中数学公式的复杂性，作为宇宙本质的一种可能性。 本文简述了该书的成书背景和内容，探讨了争议和贡献的部分。 《一种新科学》虽然是一种视野的开阔，但是离颠覆现有的科学研究方法还相去甚远。\n背景介绍 《一种新科学》是斯蒂芬·沃尔夫勒姆的一本长篇巨著。 在2002年5月14日发行之后的一个星期里，《一种新科学》初版五万册就全部销售一空，在亚马逊排行榜上一度高居榜首，成为2002年夏天最畅销的书。\n作者斯蒂芬·沃尔夫勒姆1959年出生于伦敦，父亲是相当成功的作家，母亲是牛津大学的哲学教授。 他幼年聪慧，13岁入伊顿公学，15岁发表首篇粒子物理方面的学术论文。 在获得牛津大学的奖学金并在牛津学习一年之后，即到了美国阿格纳国家实验室的理论高能物理小组工作。 1978年19岁的沃尔夫勒姆受著名物理学家穆雷·盖尔曼之邀去到加州理工学院，从事基本粒子物理学方面的研究，取得显著成就，一年内获得理论物理学博士学位。 1980年沃尔夫勒姆成为加州理工学院一员，与费曼共事。 1981年被授予麦克阿瑟“天才人物”奖，并成为该奖最年轻的获得者。之后他又到了爱因斯坦度过后半生的普林斯顿高级研究所工作，再后来又成为伊利诺斯大学的物理学、数学和计算机科学教授。\n1986年27岁的沃尔夫勒姆创立了以他的姓氏命名的沃尔夫勒姆研究公司，成为一位企业家。 1988年他的公司发布了Mathematica，一种科学计算软件。 由于其先进的符号计算理念，成为最广泛使用的数学软件之一。 沃尔夫勒姆也因此实现了财务自由。\n其实早在1981年的时候，沃尔夫勒姆就对自然界复杂性起源这一命题产生了兴趣，但是由于研发Mathematica和忙于公司事物，这一兴趣一直被搁置。 90年代初，在Mathematica第二版发行后，公司也渐渐步上正轨。 沃尔夫勒姆便将自己的几乎全部时间都投入了研究和陪伴家人中。在新世纪的开端，百万行代码之后，这些成果变成了1200多页的长篇著作《一种新科学》。\n除了畅销之外，沃尔夫勒姆还声称《一种新科学》是科学史上最为重要的一部著作，而他所做的一切不亚于牛顿的贡献。 这种豪言壮语自然十分吸引我去一探究竟。 于是在一个假期里读完了这本大部头。\n内容简介 全书围绕元胞自动机这一核心概念进行展开。 元胞自动机是由上个世纪50年代乌尔姆和冯·诺伊曼为了研究机器人自我复制的可能性提出一种离散型动力系统。 元胞自动机是研究复杂系统行为的最初理论框架，也是人工智能的雏形。\n设想一个平面上纵横相交的许多直线构成了许多网格，每一个网格就是一个元胞。 这些元胞可以具有一些特征状态，譬如被染成黑、白、红、绿等颜色。 在每个特定的时刻每个元胞只能处于一种特征状态中。 随着时间的增加，或者叫做叠代过程的进行，每个元胞根据周围细胞的状态，按照相同的规则自动地改变它的状态。 这就构成了一台元胞自动机。\n一个元胞自动机可以由四个参数唯一决定：\n 元胞活动的空间维度数 元胞可能具有的状态集合 元胞改变状态的规则 元胞自动机中各元胞的初始状态  书中主要考虑空间维度为一维的元胞自动机，元胞可能具有的状态只有两种，用颜色表示成黑色或白色，一个元胞只根据自己的状态和相邻的两个元胞的状态来改变自己的状态。 可以很容易计算出这样的一维元胞自动机的规则数有\\(2^8=256\\)种。\n图1：110号元胞自动机规则及20步后的状态\n图2：110号元胞自动机250步后的状态\n如图1所示，上面是第110（二进制表示\\(01101110_2\\)）号元胞自动机的规则，下面是其20步之后的状态（0代表白，1代表黑），初始状态为一个黑色元胞。 20步时一切似乎都还跟规则一样简单有规律。 但是如图2所示，250步之后，一些结构开始既不是周期性地也不是完全随机地出现在画面上。\n沃尔夫勒姆探索了这256种元胞自动机，以及更高维的2维和3维的情况，发现复杂性增加了但是模式类似。他将元胞自动机划分为四种模式：\n 只生成简单重复的图案，比如全黑、全白、或黑白相间如国际象棋棋盘等等 产生一些自相似的分形图案，形成稳定的嵌套结构 产生的图案具有明显的随机性 产生的图案既不是规则的也不是完全随机的复杂图案。它们呈现出某种有序性，但却不能被预测。  第四类元胞自动机是沃尔夫勒姆最感兴趣的，而规则30号和110号则是其中最有代表性的。\n书中将随机分为了三类：一是每一步输入都随机结果随机，二是初始输入随机结果随机，如混沌效应，三则是系统内在的随机性，与输入无关。 第四类元胞自动机即是这类。甚至Mathematica的伪随机数生成器都是用30号元胞自动机实现的。 而自然界的许多现象也是如此，那么这种元胞自动机和自然现象有什么关系呢？\n一方面来看，宏观上看似连续的事物微观上可能是离散的，比如水流和空气在微观尺度下都是一个个分子。 另一方面，在1994年，数学家马修·库克证明了110号元胞自动机是图灵完备的。 所谓图灵完备即是说它能像计算机一样完成所有的计算任务。\n之后的几章里，沃尔夫勒姆用元胞自动机完成了乘法、除法运算，和求素数、求平方根、求π值，甚至解偏微分方程。 并把一维元胞自动机扩展到多维元胞自动机，产生更高的复杂程度，模拟了雪花、生物细胞等等。\n更进一步，弹子球、纸牌游戏、布朗运动、三体问题等等问题中的随机性都可以用元胞自动机来解释； 流体的湍流、晶体生长的规律、华尔街股票的涨落也都可用元胞自动机来模拟； 还有自然界中的树叶、贝壳、生物色素沉着等，元胞自动机能生成与它们一模一样的图案和形态。\n传统科学在解释这些问题上展示了惊人的复杂性，有些问题甚至不能很好的解释，而沃尔夫勒姆用元胞自动机简单直接的解释了这一切。\n之后，他试图使用元胞自动机来解释整个宇宙，认为宇宙就是一个元胞自动机，从简单的规律中产生复杂性。\n同行对《一种新科学》的一些评价 在《一种新科学》出版之后，由于其畅销和沃尔夫勒姆可以称之为狂妄的一些论调，很多科学家也对这本书发表了自己的评价。\n对生物学，事实上沃尔夫勒姆所举的只是一些有限的简单的生物学例子，就得出结论说许多生物体上的差异最终几乎都与自然选择无关，有点过于武断。 也有人批评作者缺乏必要的生物学知识，而元胞自动机也从来没有产生出一种比一条蚯蚓更复杂的生物来。 或许应该肯定沃尔夫勒姆在《新科学》里给出了一些好的事例，它们说明自然选择学说还不能解释某一种生物体上的复杂特征。这属于科学，但不是新的。 生物学家们知道得很清楚，自然选择学说不能预言某一匹斑马身上的特殊条纹，就好比物理学家们知道通过解算微分方程不能预测一年之后的天气。\n复杂性和随机性可谓此书的中心论题，但是沃尔夫勒姆一直不对它们作出严格的定义，直到后面才稍稍正面论及它们。 沃尔夫勒姆是从观察者对复杂系统的感觉如何，而不是从复杂系统本身如何产生，来定义复杂性和随机性。 也就是说，它看上去是复杂的，它就是复杂的。\n同时，沃尔夫勒姆这种闭门造车不经同行评议就出书，以及受到前人工作启发但是并没有引用其文献的做法也招致了批评。\n实际上书中的许多观点前人或多或少都有过研究。 著名物理学家费曼曾表达过宇宙是离散的而非连续的观点。 而弗雷德金，计算物理学的先驱也表达过世界的本质是计算这种类似的观点。\n在接受《福布斯》记者采访时沃尔夫勒姆作出了他的大胆预言：“50年内，更多的技术，将基于我的科学而不是传统科学，被创造出来。 人们在学习代数之前将先学元胞自动机理论”。\n为了更好的评价沃尔夫勒姆的工作，我想先来回顾一下传统科学到底是怎么运行的。\n现有的科学方法 科学方法的历史 所谓科学方法，就是一种可以生产科学的过程。 科学的强大之处就在于可以在前人知识的基础上，对一个话题进行更加复杂的研究和探讨，建立更加深入的理解。 这一模型让人类可以延续几千年的知识积淀，使得社会可以持续的进步和发展。 而这一模型来之不易，经过了千年的发展。\n早在千年之前伊拉克学者海什木就在自己的实验物理学研究著作《光学书》里，指出提出问题并且依次验证它们对科学方法的重要性，因而被视为科学方法的先驱。\n到了17世纪，科学革命的先驱伽利略在著作《关于两种新科学的谈话》中发扬了这种科学方法，并且讨论了著名的两个小球自由落体运动的实验如何证伪古希腊博学家亚里士多德的“重的物体下落更快”的说法。\n经过了长期的思考与讨论，20世纪提出的假说演绎法成为了现在被广泛认可的科学方法。\n假说演绎法 假说演绎法将科学方法的过程分解为提出问题、提出假说、预测和验证假说并分析结果。\n提出问题是进行科学研究的第一步。 有时候大家可能认为问题是显而易见的。 现在我们看都知道苹果为什么会掉下来是一个问题，并且可以很容易给出答案。 但是很多人都只能意识到别人提出来的问题，只有真正进入到科学研究的过程中去，才能体会到提出一个好问题的难度和重要性。 作为研究生一年级的学生，提出一个好问题是好的研究的开始。 当问题不够好的时候，容易小而杂乱，使得自己的研究方向缺乏主线，不成体系。 所以一个深入而有价值的问题是十分重要的。\n图3：广义相对论描绘的时空坍缩\n在问题被提出之后，基于对问题的深度观察和洞见，结合自己的科学直觉，会对问题的答案有一个初步的假设。 比如牛顿看到苹果掉下来之后，给出了万有引力的假说，说万事万物（准确的说，是有质量的物体）之间都有相互吸引的力量。但是不同的科学家有不同的观察，完全可以提出不同的假说。 若干年后爱因斯坦再次审视这个问题的时候，基于自己的洞见提出了广义相对论的假说，说引力只是时空弯曲的表现，有质量的物体都会引起时空的坍缩(如图3所示)使得周围的物体向它们靠近，表现为引力。 需要注意的是科学的假说必须可以被证伪，即可以通过这个假说推论出一个可以被实验验证或推翻的结果。 从这个角度来讲，许多学科比如数学、心理学等等是否是科学还存在争议，但是在自然科学领域如物理学、化学、生物学等等，可被证伪性是被广泛认可的一个科学准则。\n图4：卡文迪许扭秤实验结构示意\n提出假说之后我们可以根据假说推论出许多预测，其中一些预测可以作为下一步验证假说的目标。 一个好的预测是可以将这个假说和同类假说区分开来的，并且实验上也是可行的。 牛顿提出了万有引力假说做出了很多预测，但是由于17世纪实验器械精度很差，一直没有能够有效验证。 直到18世纪卡文迪许扭秤实验(如图4所示)，通过精巧的设计器械精度很差的情况下测量了很小的引力变化，才验证了万有引力定律。\n通过假说做出的预测之后需要实验来验证，一个好的验证实验必须是可重复的，并且充分控制了其他干扰因素。 当许多科学家独立验证了一个假说做出的预测之后，那么这个假说就被认为是成立的了。 但是受限于时代的因素，很可能一些之前成立的假说会被后来新的观察和实验推翻。 牛顿的万有引力定律统治了物理学很长时间，直到19世纪科学家测得在所有惯性参考系中光速都是恒定的，与万有引力定律的预测不符，大家才对其产生了质疑。 直到爱因斯坦提出了相对论，解释了万有引力定律成功解释和未成功解释的所有现象之后，这一问题才得到解决。 最近被LIGO证实的引力波也是广义相对论之前的预测之一。\n这是科学方法的一般准则，也是一般科学研究基本遵守的步骤，但是要注意的是并不是所有的科学研究都会按照相同的步骤，或者在每个步骤进行到相同的程度。 科学研究还是非常需要洞察、灵感甚至一些天才的。\n《一种新科学》是否真的是新的科学？ 按照传统科学的方式，沃尔夫勒姆这种没有在前人研究的基础上进行研究，且不接受同行评议直接出书的研究过程是不科学的。 除此之外，由于《一种新科学》中的假说不可证伪，我们没有办法说明宇宙不是一个元胞自动机，所以从这个意义上来说，该假说也是不科学的。\n更进一步，因为沃尔夫勒姆提出了一种新的科学，那么用现有的科学定义来评价他是不是有些不公平呢？ 那么我们姑且承认这是一种新的科学，但是这又能给我们带来什么呢？ 是的，这是一种全新的看待问题的视角，但同时这也意味着，对传统科学方法的彻底颠覆。 因为按照沃尔夫勒姆的理论，我们虽然知道了宇宙的本源就是元胞自动机，但是除了观测它可能发生的结果之外，并不能做出有效的预测。 因为一切预测都需要重演其整个历史，而付出了这些计算时间之后，预测也就不叫预测了。 悲观来看，我们就只能静静的看着事物的演化，却对其无能为力。 在享受着传统科学方法给我们带来的巨大的社会进步的同时，这种新的科学又何尝不是一种新的倒退呢？\n另一方面，这种新的视角也是十分有趣的一种观察。 很多文学作品和影视作品都曾经设想过人类所在的宇宙只是更高等级生物的一个元胞自动机试验。 《楚门的世界》里主角楚门生来的一切都是被安排好的一个电视节目，《西部世界》里人类更是造出了与人类无异的人工智能，并将他们放于一个人造的世界里。 而最终这些影视作品里的造物都突破了自身的限制，意识到了造物主的存在并且突破了他们。 这种新的视角能否也带领人类走向突破自己的造物主的道路呢？\n结论 沃尔夫勒姆的著作《一种新科学》让我们以全新的角度来思考宇宙的本质原理，虽然在学术上存在着种种问题，但不可否认在他比前人的工作走的更加深入，而且不失为一本很好的科普读物。 不过这种这种新的科学我认为更多的是一种新的视角，而不能代替现在的科学方法，尤其是在现在的科学方法能够极大的推动社会进步而这种新科学却让我们无能为力的时候。 所以让我们心怀着这一科学假说，继续向更深层次的知识不断的探索吧。\n"
},{
	"uri": "https://dailydreamer.me/post/2017-05-21-gamification/",
	"title": "游戏化 Gamification",
	"tags": ["读书笔记", "心理学"],
	"description": "",
	"content": " 好久不写博客，把前端重写了一下之后又有了写点什么的冲动。 先把之前囤积的一些内容拿来充充数吧。 这篇是我在Coursera上浏览的一门课程Gamification的总结。 Gamification，译作游戏化，是用游戏元素和游戏设计思想去解决非游戏中的问题。 可以看到这里要解决的问题是非游戏的，只是运用了游戏中的元素和设计思想，所以不要一拍脑袋把游戏化等同于做一个游戏。\n那么我为什么对游戏化感兴趣呢，当然是喜欢打游戏啊摔是因为之前在做一个儿童坐姿检测和矫正的项目。 对于成人来说，事情比较简单，愿意去买这个产品的人，你只要提醒他，他便会自己注意改正姿势，事实上Amazon上一款畅销的产品正是这么做的。 但是儿童比较复杂，一般是家长或者学校老师买来产品然后督促他们使用，这时候他们很容易产生很强的逆反心理。 如果只是提醒甚至是惩罚的话，会加重他们的反抗心，比如你不盯着的时候他就不用，或者是伪造一些数据（这种事情我小时候也干过哈哈），这样就违背了产品的初心，削弱了客户价值。 所以一些短期的和长期的激励机制是很有必要的，而这正是游戏化可以做到的。 那么我们言归正传，看看课程里都讲了些什么。\n1. 什么是游戏化 游戏化就是用游戏元素和游戏设计思想去解决非游戏中的问题。 两个比较容易理解的例子，一个是Nike+，一个跑步App，使用各种徽章和等级来提升你跑步的激励； 另一个是Zombies Run，也是一个跑步App，设定是你处在一个充满僵尸的世界中，只有拼命奔跑才能拯救自己，比如跑的慢了就会听到僵尸离自己越来越近的声音，通过这种游戏设计来激励你完成跑步计划。\n可以看到这里游戏元素指的有分数、任务、资源、虚拟形象、奖励等。 游戏设计思想，指的是就像Zombies Run那样，像一个游戏设计者一样思考这个问题，这一点后面慢慢展开。\n游戏化可以被用在三种方面产生价值：\n 外部。比如市场、销售、客户参与等活动中。 内部。比如HR、增强生产力、众包等。 行为改变。比如养成健康生活习惯、健身、理财等等。  这里举一个行为改变的例子。 在超速检测的牌子上显示一个彩票抽奖标识，只要没有超速便可参与抽奖，奖金由超速罚单中抽出一部分来构成。 当人们看到没超速可以抽奖的时候，相比之前更加注意自己的车速，从而改变了行为。\n总而言之，游戏化可以产生激励作用，并且让人感到有趣。\n2. 游戏 游戏化的方法是从游戏中借鉴而来。我认为其中最核心的就是有趣。\n什么是游戏? 游戏是由一个松散的目标，一些基本的规则，一个放松的状态构成。 是一个你自愿去克服一些不必要的阻碍的过程。 游戏是一个神奇的圆圈，在这个圈中，你自愿遵循游戏的规则而忽略现实世界的规则。\n游戏是一系列有意义的选择 游戏的过程就是一系列有意义的选择（人生又何尝不是呢）。 因此需要维持一些元素的平衡，来保持选择的有意义。 比如规则的限制和对世界的探索，限制太死变失去了一些意外的乐趣，而没有限制的探索则容易让玩家找不到目标。 再比如学习技能和解决问题的平衡等。\n3. 游戏化思考 为什么游戏化？ 一个例子，Foursquare通过给在一个地点签到积极的玩家市长称号和徽章来激励玩家参与签到活动。 可以看出，游戏化至少有如下几个好处：激励参与，可视化进度，增加社交，习惯养成。 拿Foursquare例子来说，市长称号和徽章作为奖励十分有趣，激励了人们的参与。 获得徽章的人会把它分享到社交网络，满足自己小小的成就感和虚荣心，这促进了社交。 通过称号和徽章的完成进度可以可视化之前很难直观看到的数据。 而持续的激励则会促进习惯的养成。\n像游戏设计师一样思考 每天对着镜子大声念三遍：“我是游戏设计师！”。。。\n但是，像游戏设计师一样思考，并不同于成为游戏设计师，也不同于想玩家一样思考。 而是将系统的参与者想象成玩家。\n 玩家是游戏的中心 玩家希望有控制感 玩家专心在玩上  所以你的目标就是让玩家们开始玩，一直玩。\n设计规则 玩家的旅程被称作英雄之路\n 开始的时候要有教学导引，高亮重要的点，提供反馈，提供有限的选项后面再慢慢增加，并且不要让他失败 之后开始整个旅程的框架 最后通过不断练习达到精通  这其中挫折和成就感要相辅相成，恰到好处。\n最重要的是营造一种体验，让玩家的内心泛起涟漪，相信对游戏充满热爱的人一定会有这样的感触。走进中世纪的小酒馆看游吟诗人弹唱一曲，或是在山顶眺望洒满天穹的极光。 这里放上一个对Journey的制作人陈星汉的一个采访，说的更加详细。\n理解有趣 Nicole Lazzaro定义了四种有趣\n 简单的有趣：比如切西瓜这种休闲游戏的有趣 困难的有趣：比如三天终于解出一道数学题的成就感 社交的有趣：和朋友在朋友圈互动的乐趣 严肃的有趣：你做的选择是有意义的，比如这是我的战争  需要意识到的是：\n 有趣是可以（也应该）被设计的 有趣也可以意味着挑战 学会欣赏不同种类的有趣  寻找有趣 一个例子：LinkedIn设计了一个简单的填写账户信息的进度条，就这么一个简单的设计显著的提高了填写账户信息的人数。 可见反馈和可视化进度的力量。 微信朋友圈的未读小红点感觉也有类似功效。\n4. 游戏元素 元素金字塔  动力（语法）：限制，情感，叙事，进度，关系 机制（动词）：推动行动的进展 元素（名词）：特定的机制和动力的实例  PBL三角 PBL是最基本也是最典型的三种游戏元素\n Points（点数）: 代表进度 Badges（徽章）：代表成绩，可以收集，也可以用来社交 Leaderboards（排行榜）：排名，也可以做成个性化的排名，每个人看到的不一样，这样更有激励作用  不过需要注意的是，排行榜代表着竞争，而这有时候可能削弱玩家的积极性。 只有当玩家排名靠前的时候才会被激励，所以要慎重使用。\n元素的局限性 使用游戏元素只是最基本的游戏化方法，它有很大的局限性。 首先游戏元素并不是游戏。 其次并不是所有的奖励都是有趣的，而有趣更不仅仅是奖励。 所以不妨多从游戏设计的角度考虑考虑：有意义的选择，有挑战的谜题，精通一个技能的旅程，有活力的社区，多种多样的玩家，这些游戏设计能够更好的达到游戏化的目标。 如果想要做好游戏化，就多从伟大的游戏里学习吧。\n5. 行为主义 要从更加深层次的角度探究玩家在游戏中的状态，可以用到心理学中的行为主义。 行为主义是美国心理学大师约翰·华生（脑补了一下跟在福尔摩斯屁股后面的华生，可惜并不是）创立的学派，主张类似自然科学的实验方法定量研究心理学。 简单的讲，行为主义就是一个刺激，产生一个行为，行为产生对应的结果作为反馈。 华生的一句名言，“给我一打健康的婴儿，并在我自己设定的特殊环境中养育他们，那么我愿意担保，可以随便选择其中一个婴儿，把他训练成为我所选定的任何一种专家——医生、律师、艺术家、小偷，而不管他的才能、嗜好、倾向、能力、天资和他祖先的种族。” 虽然他做有关婴儿的这个实验后来被指有违实验伦理，以及被人八卦当时的婴儿有某种疾病，不具有代表性，实验难以复现（虽然心理学实验大都难以复现哈哈），以及华生后来和研究生助理的婚外情丑闻让他被逐出心理学界。。。 但是，此处应有但是，敲黑板，行为主义确实对心理学研究影响深远。\n对于游戏化来说，一个是可以应用一些行为主义的结论做一些小tricks。 比如玩家大多是风险厌恶的，对于defalut选项懒得去修改的，存在认知偏差的。 可以利用这些去引导玩家的行为。 同时，行为主义也指导了一种设计的方法，去观察玩家对于刺激如何反应，以及对玩家提供反馈的重要性。\n6. 自我决定理论 当然，行为主义存在着自身的局限性。 行为主义强调环境对人的影响，会把人当作一个黑盒，不去研究人内部的运作机制。 而不同于黑盒的很大一点在于，人类玩家是有情感的。 情感的一个重要部分就是动机。\n人主要有三种动机：无动机、外在动机和内在动机。 当玩家没有动机的时候，就不会觉得这个游戏有趣。 外在动机比如奖励。但过多的奖励会变得危险。 玩家会沉迷于奖励，而这使得他们必须不断得到奖励。 在这个追逐的过程中，乐趣会渐渐的流失（想想现在的手游哈哈）。 而内在动机则是玩家能够持续参与一个游戏并觉得有趣的原因。\n内在动机有三种特性：能力、自主、相关。 心流模型是对玩家内在动机的一种建模。 简而言之就是让玩家的能力和挑战能够得到匹配和成长，不会太难失去动机，也不会太简单觉得无聊。\n结语 这里只是简单的对课程内容做了一个总结，更加深入的洞察还需要不断地实践。 现在大多产品的游戏化还只是停留在使用游戏元素的层面，而更深入的使用游戏设计的机制去提高玩家的内在动机才是更加有效的方法。 无论是短期的激励，那种让人眼前一亮的a ha moment；还有长期的激励，内心内在的情感共鸣，都需要精心设计和细细打磨。\n虽然对游戏化的研究离我的专业比较远，但是能将这样一种理念装在心里，在产品设计的时候一定会十分受用。\n愿这个世界更加有趣。\n"
},{
	"uri": "https://dailydreamer.me/post/2016-06-16-mobile-application-experience/",
	"title": "移动端体验",
	"tags": ["读书笔记", "产品经理"],
	"description": "",
	"content": " 前段时间在Edx上浏览了一门课程Mobile Application Experiences，听课笔记记录如下。\nCome up an idea Research method  observation location tour: park, office\u0026hellip; contextual inquiring: working, workout\u0026hellip; think aloud diary logging: taking photo, recording video\u0026hellip; close to the time that happened interview: ask last time they do something rather than the general situation  look at what they are frustrating to do. What kind of role the environment is playing.\nAnalyze data  flow models: analyze how data flow transfer between subjects conversation analyze: look at the conversation of subjects related to a subject critical incident analyze: look at the place where people get stuck affinity analyze  Affinity analyze From data(bottom up) to find themes. It cannot help you to prove a particular hypothesis because you only talk to a few people which can represent everyone.\nThis method is about discovery, not preconceived notions.\n Create Note: each post represent one idea. Put up note Use 3 hierarchies, users\u0026rsquo; exact quotes, users\u0026rsquo; one sentence summary, theme similar between users. Group the notes use the similar theme Come up with a design through the theme  Identifying gaps listen from different source and board audience\nbuild a quick prototype and give it to them\nProposal  why you think the project need to be done what your objects and design elements are how do you test your projects if they have meet your objects.  remember to allow people to navigate through your proposal easily\nBuild and test your idea with paper prototype Concept modeling  before + after: how is life different with your app user mental model: how do user think about the key part of your app architecture model user types content types service model: what are all the user touch point with your system  User cases Structure(flow) How your product empower people\u0026rsquo;s work flow.\nScreen design  where I am, where to go, how to get here set expectations and provide feedback ergonomic design rely on recognition rather than recall  Paper prototype start with paper: people tend to critical of overall concept\nthen mock up screens: people tend to critical on design details\nUsability testing about 5 people can cover 80% situations\nRole: moderator, computer, note taker and user.\n"
},{
	"uri": "https://dailydreamer.me/post/2016-06-15-fund-tips/",
	"title": "买基金给我加薪",
	"tags": ["读书笔记", "理财"],
	"description": "",
	"content": " 一本有关基金的入门书籍，一些基本知识和理念。\n术语 选中长期绩效好的基金。\n所选择的基金公司不能只重视一只基金。\n基金风险指标：\n 标准差：过去一年净值的稳定程度，越低越稳定 beta值：基金波动幅度与打大盘的比值，越低越稳定 夏普指数：每单位反风险带来的收益，越大收益越高。  定投秘籍  越早进场越好 账面亏损无所谓，赎回时要赚钱 定期检视，适时去芜存菁（绩效连续在同类型中处在下游） 只设停利，不设停损（简单计算，年利率是定存的5倍）  单笔投资秘籍  熟悉市场脉动 分批进场，买跌不买涨 定期检视，停利更要止损 懂得分批出场  结合基本面（经济景气）和技术面\n基本面  国内生产总值 主要经济指标 美国采购经理指数 消费者物价指数 美联储态度 消费者信心指数  技术面  季线 KD线  结合操作 定投的收益也是市场的重要指标\n进场时：先定投，低谷时单笔投资\n出场时：先2-3次赎单笔投资，再一次赎回定投\n获利后滚入再投资\n"
},{
	"uri": "https://dailydreamer.me/post/2016-06-09-inspired-by-functional-programing-language/",
	"title": "从函数式语言想到的",
	"tags": ["编程", "编程语言"],
	"description": "",
	"content": " 最近看了一本书Seven Languages in Seven Weeks。 原来一直都在面向对象编程，对函数式语言了解并不多，看完这本书之后还是很受启发，接触了许多不同语言的新的思想。\n各种编程范式 imperative programming 古老的编程范式，以冯诺以曼结构的机器思考的方式编程，如C语言。\nobject oriented programming 现在正当年的主力编程范式，如Java、C#、ruby、python，以及深度融合了函数式思想但本质还是OOP的scala。\n它的分支Prototype-based programming，如JavaScript，是一种十分灵活的编程方式。 没有Class定义，所有的Object都以另一个Object为prototype，可以很灵活的改变原型链上的Object的数据和方法。\nlogic programming 面向推理逻辑的特定编程范式，是一种高等级的抽象，如prolog，声明定义和推导即可得出特定问题的答案。\nfunctional programming 被认为是下一代的编程范式。 函数式编程范式基于lambda calculus的思想，很早就在大名鼎鼎Lisp中出现。 其核心思想是认为一切程序都可以由纯函数组成，纯函数没有副作用，输入一样则输出必然一样； 所有数据结构都是immutable的，其值不能被改变。\n早年由于我们的计算机架构是冯诺以曼结构，其基本操作都是基于副作用的，因此这种函数式编程带来的性能上的极大损失使其没有像命令式编程一样成为主流语言。 现在随着计算机性能的提升以及相关理论和实现的完善，函数式编程的思想带来的好处逐渐体现，并且也积极的影响着其它现在的主流语言。 同时涌现了一批为了兼容现有平台而作出一定妥协的”过渡性语言”，如Scala（Better Java）、Clojure（JVM上的Lisp）、F#（.Net上的OCaml）。\n函数式语言的积极影响 基于immutable思想的数据结构 immutable带来的好处是程序的结果更加的可以预测，变量不会在你看不见的地方被偷偷改变。 而且在多核的并行架构下Immutable能够避免复杂的状态和逻辑维护，使程序更加高效简单。\n过去Lisp中主要的immutable数据结构是List,在某些情况下这种数据结构的性能非常糟糕（如查找是O(n)）。 而现在一些精巧复杂的树状的数据结构可以兼顾immutable和性能（以一定的存储空间为代价），如Ideal Hash Trees中的Hash array mapped trie(HAMT)。 这篇文章详细讲解了Clojure中的Persistent Vectors（虽然叫Vector但只是接口一样，实际这货是个树）的实现原理。 它基于HAMT，能够在保持immutable维护过去状态以供回滚的同时达到增加、更新、查找都为O(1)的性能。 知乎上的这个讨论介绍了一些其它的相关数据结构。\n基于immutable的系统 Nix OS是一种使用Nix packager manager的纯函数式思想的系统。 Nix packager manager也可以在Linux和Mac OS X上使用。 它将每一个软件包都独立开来，升级软件的时候不会影响原来已经安装好的其它版本的该软件，使得软件可以轻松回滚，并且不会出现由于版本导致的各种问题，是ruby的RVM，node.js的NVM，python的virtualenv等等软件所解决问题的终极解决方案。\n类型 Haskell拥有强大的类型系统。 static type是指其编译时进行类型检查，strong type是指其类型检查要求类型严格匹配。 配合type inference，Haskell的类型系统做到了你不需要时感受不到，需要清晰接口时可以显示声明。 它永远在保障着程序的正确性，不会产生JavaScript中一些被人广泛诟病的错误（这个视频我笑了好久。。。）。 Scala中也有type inference，但是由于JVM的限制功能很有限。\nHaskell中的type class可以优雅的实现generics和polymorphism，并且可以避免很多OOP中因为不能把函数作为一等公民传递（高阶函数）而造成的臃肿的设计模式。 Julia中multiple dispatch更进一步，根据每个参数的类型不同调用不同的函数实现，更符合直觉，且避免了OOP中dynamic dispatch的动态查找带来的性能损失。\n并发 OOP中对于并发的处理通常是基于thread以及共享内存和互斥锁，这个模型被实践证明即使是有经验的程序员也很难驾驭。 而许多函数式语言提出了更好的解决方案。\nerlang是为了稳定的企业级基础服务而开发的语言。 erlang虚拟机使得新建进程更加轻量，进程间通讯更加方便。 结合immutable特性以及actor进程池模型和消息传递来解决并发问题。 erlang虚拟机还有一个厉害的特性是能够在语言内轻易管理进程的生命周期，这催生了独特的let it crash哲学，以及不用停止程序即可修改代码等等的神奇功能，使得erlang程序可以运行多年而不用重启。\nscala中也使用actor作为并发模型。 clojure中借鉴了关系型数据库的transactional特性，使用software transactional memory管理并发。\n这些模型都被实践证明更加容易产生可靠的代码且更容易理解。\nPattern matching 不同于传统OOP对象相等比较的是引用相等，如Java中String类型的==和equals()的令人迷惑的区别，Pattern matching是深度比较两个对象，更加符合直觉，并且配合immutable也可以有很好的性能。 当然Pattern Matching更加灵活，带来了匹配类型，destructing等等实用的功能。\nmeta programming Lisp中程序即数据，整个程序就是用List数据结构表达的，使得其macro远远强大于C的字符串替换，可以实现很多优雅的domain specific language(DSL)。 后来很多语言都将macro和meta programming作为自己的重要特性，即使是拥抱了OOP的ruby和scala。\n其它 如Currying，Functor，Applicative，Monad等等新的概念和抽象，使用Maybe Monad杜绝Null这一Java程序员永远的痛等等。\n总结 函数式编程为我们带来了更优雅简洁易懂的程序，以及许多优秀的思想。 虽然今天的主流语言仍然是OOP，但是我们可以靠自己慢慢推动新一代编程范式的发展，找到最佳的结合点。\n需要注意的是不应该盲目推崇函数式编程的思想。 编程语言里还有另一种实用派，学术派眼中的“另类”，从实际出发得出的迥然不同的语言，如C和go。 不同的思路有着不同的权衡取舍，取其精华去其糟粕，结合自己的使用场景选择，合适的才是最好的。\n"
},{
	"uri": "https://dailydreamer.me/post/2016-05-25-webrtc-introduction/",
	"title": "WebRTC简介",
	"tags": ["编程", "WEB"],
	"description": "",
	"content": " WebRTC简介 WebRTC是一种在浏览器中无需任何插件的点对点(P2P)实时视频、音频、数据交流协议，其中RTC是实时沟通(Real Time Communication)的缩写。 过去，实时沟通昂贵且实现复杂，需要专用的视频和音频设备及技术，使得将其集成进已有服务昂贵且费时。 后来，Google开源了Gmail和Hangouts中使用的RTC技术，并且参与W3C相关规范的制定。 2011年，WebRTC第一个版本被实现。 现在WebRTC技术已经被WhatsApp, Facebook Messenger等应用广泛使用。\nWebRTC主要实现了3个API，getUserMedia、RTCPeerConnection和RTCDataChannel。 其中getUserMedia定义了来获取设备上的视频(包括摄像头输入和屏幕输入等)、音频流的接口。RTCPeerConnection定义了用于处理两个客户端之间的流数据的接口。RTCDataChannel定义了用于处理两个客户端之间任意数据收发的接口。\n使用WebRTC过程 使用WebRTC时需要如下步骤：\n 使用getUserMedia获取MediaStream流数据，此时可以用Constraints对MediaStream的帧率、宽、高等进行设置。 使用RTCPeerConnection初始化客户端session，将MediaStream附加到session上。 获取网络信息(如IP地址、端口等)，与其他客户端进行Signaling(信令交换)。 该过程使用SDP（Session Description Protocol）协议。 Signaling交换流媒体数据信息(如编码、分辨率等)。 Signaling过程完成，直接点对点交换流媒体数据MediaStream。 (可选)建立RTCDataChannel进行数据交换。  实际应用中，会遇到客户端处于防火墙或NAT之后等复杂情况，这时需要用到STUN协议或TURN协议等来实现防火墙和NAT穿透，获取真实的网络信息。\n由于WebRTC在建立session之后流媒体数据是点对点传输，这样虽然很快，但是如果遇到大量客户端的视频会议等场景，客户端之间需要两两连接，对于客户端带宽要求很高。 这时就需要MCU(Multipoint Control Unit)来改变网络拓扑，节省带宽提高性能。\nWebRTC在Signaling过程中需要使用其他双向数据协议进行信息交换，如WebSocket或XMPP等。\n由于WebRTC标准实现还未最终完全确定，各个浏览器都需开启实验性功能才能使用，可以考虑Chrome插件或者使用Electron封装成桌面程序的形式提供更好的用户体验。\n"
},{
	"uri": "https://dailydreamer.me/post/2016-05-24-some-design-books/",
	"title": "读过的一些设计书籍",
	"tags": ["读书笔记", "设计"],
	"description": "",
	"content": " 最近翻了一下之前记的一些读书笔记，将读过的一些经典的设计书籍总结一下，记录在这里。\n不要让我思考 整本书都在传递一个强烈的概念：不要让我思考。用户不喜欢思考，比如用户阅读网页的方式是扫描，选择的时候抱着满意即可、勉强应付的心态。 强迫用户思考会使他们离开你的产品。\n下面是几个具体的优化：\n 明显标识可点击处，划分页面区域，降低视觉噪音 去掉不必要的文字 统一导航  设计心理学 整本书从心理学的角度看设计。\n人认知的基本模型是目标 -\u0026gt; 行动 -\u0026gt; 反馈，好的产品应该有一个好的概念模型\n 减少目标到行动认知负担，也即上面提到的不要让我思考 产生合理的反馈  具体有下面几个原则：\n 应用存储于外部世界(物理环境)和头脑中(文化标准)的知识，建立界面到功能的自然匹配 简化任务结构 注重可视性，比如一个按钮是一个功能 利用自然和人为的限制因素 考虑可能出现的人为差错，防止错误需要警报或强迫性功能 若无法做到以上几点，就标准化  写给大家看的设计书 这本书主要讲了视觉设计中的几个基本原则：\n 亲密性：将相关的项组织在一起，物理位置的接近意味着存在关联 对齐：任何元素都不能在页面上随意摆放，每个元素应当与页面上另一个元素存在某种视觉联系 重复：把现有的一致性向前推进一步 对比：让他们截然不同吧  其他还有注意留白。\n设计中的设计 日本设计师原研哉的作品。 一开始只是被书中精美的图片和排版所吸引，但是也收获了不少。\n设计师坂茂应原研哉之邀再设计卫生纸时，设计了方形卫生纸。 由于方形的阻力更大会使每次使用的纸变少，而且方形相较于原型更方便运输。 这种再设计可以让人从习以为常的日常中跳脱出来，从另一个角度看问题。\n原研哉说，设计师在其受众头脑中创建一种信息建筑，受众通过视觉听觉味觉触觉等感官信息，以及被外界重新唤醒的记忆来构建信息建筑。\n原研哉对书和纸的看法：书作为一种存储信息的媒介可能有诸多不便。 但是如果我们好好观察一下信息与个人的关系，会发现重要的其实是我们能多深入的理解信息。 就书而言，我们会有更愉快的用户体验，我们会更中意于那些以适当重量和质地的材料呈现的信息。 这可能就像食物与人类的关系一样。 因为电子媒介的兴起，纸终于能做他该做的事情了——充当一种本性迷人的材料。\n他还是无印良品咨询委员会委员。 无印良品的理念是无设计的设计，简单，追求的不是这个好而是这样就好。\n"
},{
	"uri": "https://dailydreamer.me/post/2016-04-25-dom-and-dom-event/",
	"title": "DOM和DOM Event",
	"tags": ["编程", "WEB"],
	"description": "",
	"content": " DOM和HTML，JavaScript，CSS的关系 Document Object Model(DOM)是W3C制定的一种语言无关的面向对象的文档模型，规定了一组可编程的interface需要实现的属性和方法。 HTML和XML文档实现了DOM，因此拥有面向对象的特性，其结构、样式、内容等可以被其他语言的DOM实现操纵。 DOM Level 4是2015年的最新一版标准。\nHTML中\u0026lt;script\u0026gt;元素中嵌入的JavaScript就是DOM的一种实现，如下所示：\nvar paragraphs = document.getElementsByTagName(\u0026quot;P\u0026quot;); // paragraphs[0] is the first \u0026lt;p\u0026gt; element // paragraphs[1] is the second \u0026lt;p\u0026gt; element, etc. alert(paragraphs[0].nodeName);  其中document对象，getElementsByTagName方法，alert方法，nodeName属性均是DOM标准规定的。\n你也可以用其它语言操作DOM，如下的Python示例：\n# Python DOM example import xml.dom.minidom as m doc = m.parse(\u0026quot;test.xml\u0026quot;); doc.nodeName # DOM property of document object; p_list = doc.getElementsByTagName(\u0026quot;para\u0026quot;);  HTML是一种文档标记语言，HTML元素除了实现DOM的interface之外，还实现了HTML标准中规定的一些interface。如下示例：\nvar table = document.getElementById(\u0026quot;table\u0026quot;); var tableAttrs = table.attributes; // Node/Element interface for (var i = 0; i \u0026lt; tableAttrs.length; i++) { // HTMLTableElement interface: border attribute if(tableAttrs[i].nodeName.toLowerCase() == \u0026quot;border\u0026quot;) table.border = \u0026quot;1\u0026quot;; } // HTMLTableElement interface: summary attribute table.summary = \u0026quot;note: increased border\u0026quot;;  attributes属性是DOM标准，border和summary属性是HTML标准。\n其它XML的方言如SVG等也有实现DOM之外的标准。\nCSS是一种为DOM文档标记样式的语言，而DOM Element种的style属性被解释为行内样式表。\nDOM Event DOM Level 2中规定了基本的DOM Event Model，包括事件的处理流程以及注册方法等等。 这里主要讲一下事件处理流程，感觉和WPF的事件机制很相似。\n基本流程 在DOM implementation中触发事件后，触发事件的元素EventTarget被指定给Event对象的target属性。 如果该事件没有使用事件捕获和事件冒泡，那么所有的EventListener被执行后事件处理结束。 如果使用了事件捕获或事件冒泡，那么事件传播过程如后文所示，依次执行过程中所有元素上注册的该事件的EventListener。 执行过程是同步的，且一个EventListener内的异常不会影响后续EventListener的执行。\n事件捕获(Event capture) 事件捕获阶段，事件从DOM树的顶端元素，通常是Document，沿着EventTarget的祖先元素向EventTarget传播。 设置addEventListener方法的useCapture属性为true可以使该EventListener在事件捕获阶段截获由其后代元素产生的相应事件，同时该EventListener在事件冒泡阶段不会再被触发。\n注意和WPF等基于delegation的模型不同的是，截获的是后代元素的相应事件，这意味者如果EventTarget上的设置useCapture的EventListener不会被触发，因为自己不是自己的后代； 并且指定的不是一个EventTarget，而是一种特定的事件类型，如果事件类型不同不会被触发。\n事件冒泡(Event bubbling) 事件冒泡阶段，一开始和没有使用冒泡的事件一样，所有EventTarget上的EventListener都被执行。 然后从EventTarget沿着DOM树，向其祖先元素传播，直到DOM树顶端，过程和事件捕获相反。 设置了useCapture属性的EventListener不会在这一阶段被触发。\n事件传播的链条在事件被触发时就已经确定，传播过程中DOM树的改变不影响传播过程。\nstopPropagation 在事件传播的过程中，如果一个EventListener调用了Event对象的stopPropagation方法，那么事件会停止传播，链条上后续元素的EventListener不会被触发。\npreventDefault 一些事件被指定为cancelable。这些事件的DOM implementation通常都会有一些默认的事件处理方法。在这些事件上调用preventDefault方法可以阻止这些事件处理方法的执行。\n如下例子展示了用preventDefault阻止非小写字母的输入。\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;preventDefault example\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;请输入一些字母,只允许小写字母.\u0026lt;/p\u0026gt; \u0026lt;form\u0026gt; \u0026lt;input type=\u0026quot;text\u0026quot; id=\u0026quot;my-textbox\u0026quot;/\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;script type=\u0026quot;text/javascript\u0026quot;\u0026gt; function checkName(evt) { var charCode = evt.charCode; if (charCode != 0) { if (charCode \u0026lt; 97 || charCode \u0026gt; 122) { evt.preventDefault(); alert(\u0026quot;只能输入小写字母.\u0026quot; + \u0026quot;\\n\u0026quot; + \u0026quot;charCode: \u0026quot; + charCode + \u0026quot;\\n\u0026quot; ); } } } document.getElementById('my-textbox').addEventListener( 'keypress', checkName, false ); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  常用的MouseEvent 有click，mousedown，mouseup，mouseover，mousemove，mouseout。\nclick是在同一屏幕位置的mousedown和mouseup先后依次触发后被触发。\nMouseEvent都会冒泡，并且除mousemove外都Cancelable。\n"
},{
	"uri": "https://dailydreamer.me/post/2016-04-14-css-cheat-sheet/",
	"title": "CSS Cheat Sheet",
	"tags": ["编程", "WEB"],
	"description": "",
	"content": " HTML block element块级元素，撑满一行\ninline element行内元素，宽度包围内容\nCSS原理 选择符 a, b {} 同时选中a和b\na b {} a是b的祖先元素时选中b\na \u0026gt; b {} a是b的父元素时选中b\na + b {} a紧邻b时选中b\na ~ b {} a和b是同胞时选中b\n* {} 全部选中\n.a {} 选中a类\n#a {} 选中id为a\na.b {} 选中同时为a标签和b类\n.a.b {} 选中同时为a类和b类\na[b] {} 选中a标签中带有b属性的\na[b=c] {} 选中a标签中b属性值为c的\n伪类 a标签 a:link a:visited a:hover a:active\na:focus a:target\n一组同胞元素中的第几个 a:first-child a:last-child a:nth-child(n) a:nth-child(odd) a:nth-child(even)\n伪元素 a::first-letter a::first-line\na::before a::after\n搜索引擎不会索引伪元素\n继承 字体颜色等相关属性会继承，位置等相关属性不会继承\n浏览器层叠样式表顺序  浏览器默认 用户样式表 作者链接样式表（按链接先后顺序） 作者嵌入样式表 作者行内样式表  特指度：包含多少标签、类名、ID等（I-C-E三位数），特指度高的优先级高\n特指度相同时顺序靠后的优先级高\nCSS属性 文本值\n数字值\n px 像素 em 字体中M的宽度 ex 字体中x的高度 百分比  颜色值（颜色名，RGB，HSL，16进制）\n定位元素 垂直外边距叠加：垂直方向相邻两个box取margin较大的作为外边距\np { font-size: 1em; margin: .75em 30px; }  如上排版文字最好垂直相对外边距，水平绝对外边距\n给设定了宽度\\高度的盒子加边框、内边距、外边距会使盒子更宽\\更高。CSS3的box-sizing属性可以消除这一特点。\nposition  static：普通文档流 relative: 仍然在文档流中，相对原来的box位置变化，原来box占据的位置不变 absolute：从文档流中脱出，会随页面滚动 fixed：从文档流中脱出，不会随页面滚动  定位上下文：带有非static position的最近祖先元素，默认是body。\ndisplay  inline block none（空间会被回收）  最近支持越来越好的flexbox布局，值得有空仔细研究。\nbackground  background-repeat background-size background-attachment  css3支持多张背景图片，先列出的在上层\n背景渐变\n字体和文本 em相对最近的被设置过字体的祖先大小\nCSS3 rem相对root即body字体大小\n text-indent text-align vertical-align: sub(下标) super(上标) top middle bottom  Web字体\n界面组件 label的for属性可以把标签和控件关联起来\nfieldset表单域\n用section块级元素包裹label和input\n响应式布局 媒体查询 媒体类型：all handled print screen 等\n媒体特性：max-device-width max-width orientation\nand not all 等逻辑运算符\n"
},{
	"uri": "https://dailydreamer.me/post/2016-04-09-spa-jwt-auth/",
	"title": "单页应用JWT身份认证",
	"tags": ["编程", "WEB"],
	"description": "",
	"content": " 最近在开发一个单页应用，采用了前后端分离的策略，即后端只提供RESTful接口，前端进行路由，通过Ajax和后端交互。 为了保持RESTful服务的无状态，要避免使用sesseion来保存登录状态，可以使用token方式来进行认证。 这篇博客就来说一下利用JWT(JSON Web Tokens)进行身份认证，以及如何防范MITM，XSS与CSRF攻击。\nJWT JWT是RFC 7159规范，利用JSON和一种可选的签名算法定义了一种紧凑且自恰的结构。 相比基于XML的SAML方式更加简单紧凑，节省流量且JSON格式方便处理。 相比基于session的认证方式不用在服务器端维护状态，易于扩展；不用查询数据库，性能更好；可以授权给别的应用。 缺点是实现过于复杂，很多语言库都没有实现完整的JWT规范。\nJWT由三部分组成，Header.Payload.Signature。\nHeader Header包含签名算法和type，如下：\n{ \u0026quot;alg\u0026quot;: \u0026quot;HS256\u0026quot;, \u0026quot;typ\u0026quot;: \u0026quot;JWT\u0026quot; }  Base64编码后即为Header。\nPayload 主体内容部分。有一些保留属性，如iss (issuer), exp (expiration time), sub (subject), aud (audience)等。也可以声明私有属性。\n如下：\n{ \u0026quot;sub\u0026quot;: \u0026quot;1234567890\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;John Doe\u0026quot;, \u0026quot;admin\u0026quot;: true }  Base64编码后即为Payload。\nSignature 签名部分，生成过程如下：\nalg( base64UrlEncode(header) + \u0026quot;.\u0026quot; + base64UrlEncode(payload), secret)  其中alg为Header中声明的签名算法，常用的如SHA256等。 结合secret校对签名可以保证JWT的完整性和不可伪造性。\n身份验证过程 后端API除了注册和登录外的需要身份验证的接口都对JWT签名进行验证，不通过则返回401 Unauthorized，保护API。 用户注册登录后生成JWT返回用户，用户访问受保护的API时需要随请求发送JWT至服务器端。\n两种常见的安全威胁 接下来看看单页应用开发中几种常见的安全威胁：MITM(Man-In-The-Middle)，XSS(Cross-site scripting)和CSRF(Cross Site Request Forgery)。\nMITM MITM是指在数据传输过程中窃听甚至篡改线路中的数据，如窃听WIFI和ARP欺骗等等。 这里我们在应用层主要使用SSL加密，即HTTPS防范它。 在后端response的header的cookie设置Secure字段，强制cookie使用HTTPS传输。\nXSS XSS是指将恶意脚本注入站点，如在用户聊天框输入的地方输入如下内容\n\u0026lt;img src=x onerror=\u0026quot;alert(XSS!)\u0026quot;/\u0026gt;  如果不经过滤就显示内容，那么该网页就会执行被注入的脚本，弹出一个alert。\n防范XSS的关键是不要信任任何用户提供的内容，对它们进行充分的过滤再使用。 并且在后端response的header的cookie设置HttpOnly字段，禁止浏览器Javascript脚本操作cookie。\nCSRF CSRF利用了一个事实，即如\u0026lt;img\u0026gt;标签等发起的简单的GET请求是不被同源策略约束的。 如果攻击者在他的页面中加入一个标签如下：\n\u0026lt;img src=\u0026quot;http://example.com/api/user\u0026quot;/\u0026gt;  引诱你访问这个界面后，该标签像example.com的user api发送GET请求，并且会附上你的example.com的cookie，那么攻击者就能得到你在example.com的user信息。\n要防范CSRF，主要有两种方式。 可以在后端的response的header中加入Access-Control-Allow-Origin白名单，限制跨域访问； 或者使用一些Synchronizer Token技术。 如在用户新建立一个sesseion时产生一个独有的Synchronizer Token，存储在表单的隐藏域、URL参数等地方，JWT的payload中也存储一份。 然后每次请求时前端都通过Javascript脚本发送Synchronizer Token,而这个token攻击者无法获取（除非先进行XSS）。 据此，后端就可以验证前端的身份非攻击者。\n前端JWT存储 JWT存储有两种方式，localStorage和cookie。\nlocalStorage 后端返回JWT后，前端存储在localStorage中，每次请求时设置HTTP Authorization Header，使用Bearer scheme，如下：\nHTTP/1.1 GET /api/user Host: example.com Authorization: Bearer Header.Payload.Signature  后端验证即可。\n存储在localStorage的优点是不使用cookie，避免了JWT被MIMT和CSRF攻击。缺点时localStorage可以被Javascript访问，容易被XSS攻击。\ncookie 后端response的header设置Set-Cookie，如下\nHTTP/1.1 200 OK Set-Cookie: token=Header.Payload.Signature Secure; HttpOnly;  前端发器跨域请求时，正确设置(见上一篇blog)后会同时附带cookie，后端验证即可。\n存储在cookie的优点是在设置了Secure; HttpOnly;后防范了XSS和MIMT攻击，但是容易收到CSRF攻击。\n总结 JWT提供了一种很好的身份验证方式，至于存储在哪里向来有很多争论，这是一个权衡取舍的过程。\n"
},{
	"uri": "https://dailydreamer.me/post/2016-04-08-cors-solve-same-origin-policy-problem/",
	"title": "CORS解决单页应用跨域问题",
	"tags": ["编程", "WEB"],
	"description": "",
	"content": " 同源策略 最近在开发一个单页应用，采用了前后端分离的策略，即后端只提供RESTful接口，前端进行路由，通过Ajax和后端交互。 这时前端和后端部署在不同的服务器上。 而浏览器为了安全，运行在浏览器中的Javascript脚本受到同源策略限制。\n同源是指协议+主机名+端口号全部相同，称为同源。 详细见下表，是跟\u0026rdquo;http://www.example.com/dir/page.html\u0026quot;做比较。\n   Compared URL Outcome Reason     http://www.example.com/dir/page2.html Success Same protocol, host and port   http://www.example.com/dir2/other.html Success Same protocol, host and port   http://username:password@www.example.com/dir2/other.html Success Same protocol, host and port   http://www.example.com:81/dir/other.html Failure Same protocol and host but different port   https://www.example.com/dir/other.html Failure Different protocol   http://en.example.com/dir/other.html Failure Different host   http://example.com/dir/other.html Failure Different host (exact match required)   http://v2.www.example.com/dir/other.html Failure Different host (exact match required)   http://www.example.com:80/dir/other.html Depends Port explicit. Depends on implementation in browser    Javascript不能访问非同源下的资源，如cookie，localstorge等，这也意味着ajax请求后返回的数据会被浏览器认为是非同源而禁止Javascript操作。 通常的解决方法有JSONP(JSON with Padding)和CORS(Cross-origin resource sharing)。 当然如果要求实时性的话也可以考虑WebSocket协议，这点本文不展开。\nJSONP HTML标准里的\u0026lt;script\u0026gt;标签，它可以调用部署在CDN上或其他服务器上的非同源Javascript。 JSONP实际上是利用了这一点，和服务器端约定，在发送请求时加入了一个回调函数的参数。 如Jquery中设置参数dataType: \u0026quot;jsonp\u0026quot;后，请求相当于插入页面如下标签\n\u0026lt;script src=\u0026quot;http://www.example.net/api/example?callback=mycallback\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;  服务器端返回的payload为mycallback(data)，通过\u0026lt;script\u0026gt;标签执行，就完成了ajax请求。\nJSONP的优点是实现简单，兼容性很好。 缺点是只支持GET请求。\nCORS CORS是W3C推荐的跨域HTTP请求的新机制，它可以支持如下请求：\n XMLHttpRequest(即ajax请求) Web Fonts WebGL textures canvas中drawImage产生的Images/video frames CSS Scripts  简单请求 简单请求，是指满足如下条件的请求：\n只允许如下方法：\n GET HEAD POST  除了浏览器自动设置的属性（如Connection, User-Agent等), 只允许设置如下头部属性：\n Accept Accept-Language Content-Language Content-Type  只允许如下Content-Type值:\n application/x-www-form-urlencoded multipart/form-data text/plain  对于简单请求，要允许CORS，需要在后端返回的response的header中设置Access-Control-Allow-Origin允许前端服务器地址的ajax请求，可以使用通配符或白名单。 如Access-Control-Allow-Origin: *允许所有跨域请求，Access-Control-Allow-Origin: http://example.com允许前端服务器example.com的跨域请求。\n发送CORS跨域请求默认不带cookie。 可以设置request的header中xhr对象withCredentials: true一同发送cookie，同时后端返回的response的header中设置Access-Control-Allow-Credentials: true接收cookie。 注意使用cookie时Access-Control-Allow-Origin的值不能是通配符*。\nPreflighted requests 除了简单请求外的请求都是复杂请求。 在发送复杂请求之前需要先发送一个OPTIONS方法的Preflighted requests，后端确认安全后再发送正式请求。 具体设置可以参考W3C推荐标准。\n"
},{
	"uri": "https://dailydreamer.me/post/2016-03-20-a-new-kind-of-science/",
	"title": "一种新科学",
	"tags": ["读书笔记", "科学"],
	"description": "",
	"content": " 本书作者是Mathematica之父Stephen Wolfram。 他在完成Mathematica后挣了一大笔钱，然后几十年一直在搞自己喜欢的研究和探索，最终著成本书（论经济基础对研究的重要性）。 虽然书中的研究缺少确实的证据而更多的是作者的猜测，但是以目前的科学也不足以证伪。 不过有计算复杂性科学家发过paper评判这种没有同行评阅和修改的出书模式，并且质疑了其内容的价值。 但是作为思路开阔一读也未尝不可。\n而且这本书实在是太长了，并且充满了各种论断但是缺少证据，最终没有看完，日后有机会再补完。\nThe Foundation for a New Kind of Science 实际上系统理论没必要必须建立在传统数学规律之上。 使用传统数学规则经常无法使用简单的规则解释复杂的自然现象，但是遵从简单规律的程序却可以产生复杂的结果。\nPrinciple of Computational Equivalence: Whenever one sees behavior that is not obviously simple - in essentially any system - it can be thought of as correspoding to a computation of equivalent sophitication.\n这个原理揭示了传统数学规则的局限性，它只能解释简单的系统因为它大大简化了计算复杂度。\n现在的物理太依赖连续的数学表示或概率，但是离散的其实更简单，并且可以解释很多基本现象。\n现在数学不能解释复杂的生物系统，而简单程序可以。\nA new kind of science不仅能够解释各个学科的复杂问题，也能对经典的基础问题进行解释。\nThe Crucial Experiment How do simple program behave? 细胞自动机即使从简单条件开始，遵从简单条件发展，也会展示惊人的复杂性，正如我们在自然中看到的。\n尽管每个cell都遵从相同的规律，但是因为环境的不同，它们的行为也不同。\nThe need for a new intuition 细胞自动机的复杂性与我们认为一个复杂事物必然构成复杂的直觉相反，而这种直觉可能来自于工程中，那里我们从功能出发，逐步将系统分解到细节，我们能预测系统的一切行为。 但是却不是这样，事实上类似细胞自动机这种不可预测的结构在自然中很常见。\nWhy these discoveries were not made before 早期计算机太昂贵，而这些工作没有传统科学框架下的意义。\n既需要基础科学的知识，又需要计算科学的经验和直觉。\n许多发现都指向了new kind of science，如二维细胞自动机the game of life，但是都被人们忽略了。\nThe world of simple programs 二色一维两个邻居的细胞自动机有256种情况，三色有3^8种情况，但是其中的模式大都类似。\nMobile Automata: 一次只有一个active cell，下一步active cell左移或右移。\nactive cell越多，越容易有复杂性。\nTuring machine, Substitution system…\n系统依赖的规则稍加复杂，结果就显示出惊人的复杂性，但是之后依赖规则再复杂也不会有太大的不同。\n大量的实验，简单的实验适合用计算机编程，但同时也可能模拟复杂现象。\nSystem based on numbers 2进制digital sequence显示出和细胞自动机相似的复杂性。\n递归序列、素数序列等等\u0026hellip;\n连续的细胞自动机，微分方程，连续的系统也能产生复杂的结构。\nTwo dimensions and beyond 二维三维的系统有类似的复杂性。\n基于限制的系统，也是当规则复杂到3*3时才会产生随机现象。\n传统数学规律大多基于限制，因此难于发现复杂性。\nStarting from randomness 随机开始的细胞自动机会最终归于4个模式。\nMechanisms in programs and nature University of behavior 自然中的一些复杂性和细胞自动机中表现出的模式相同。\nThree mechanisms of randomness 三种导致随机的机制：每一步输入均随机、初始输入(敏感)随机、无外界随机因素intrinsic randomness generation。 船在水上的运动是第一种，混沌效应是第二种，第三种有rule 30自动机，伪随机数生成器，自然界中最常见第三种。\n实际设备的问题限制了随机性的观测，即内部状态恢复的速率和不可避免的相关性。\nMathematica使用rule 30细胞自动机产生随机数。。。\n大部分随机数生成器使用multiplier 65539 linear congruential generators，因为它更易被数学分析，但是有最大重复间隔使得不是完全随机。\nintrinsic randomness generation和自然界随机的共同特征是可重复实验，而其他两种机制则不可重复。\nintrinsic randomness generation对扰动的容忍程度大于第二种机制，而实际系统中总是有扰动的。\nThe phenomenon of continuity 宏观上看起来连续的系统微观上也可能是离散的，如水流和风等。\n这样的原因之一是随机性。\nOrigins of discreteness 连续的系统也能引起离散的行为，如量变引起质变的烧开水。\nThe problem of satisfying constraints 基于限制的大都只能产生简单的现象。\nOrigins of simple behavior uniformity, repetition, nesting都可以从各种机制中产生。\nImplications for everyday system Issues of modeling 为日常生活中的复杂现象通过简单程序的规则建模。\n模型可以是粗略的描画复杂现象的轮廓，而不必使得模型内部的部分对应于实际系统的部分。\n传统模型大多是数学等式的集合，因而不能很好的刻画复杂现象； 传统模型很难轻松得到结果，由于连续不能直接运行在计算机上。 而简单程序模型就没有这些问题。\nThe growth of crystals 用二维六边形细胞自动机模拟雪花生成结构。\nFluid flow 只要粒子和动量的数量级一致，即使是高度粒子模型也能显示出湍流的行为。\n传统的数学解释认为湍流系统是出事输入敏感的，但是细胞自动机模型却不这么假设。 这也更符合实际现象。\nFundamental Issues in Biology 从部分organism角度看生物，在显微镜规模下，就是简单程序的细胞自动机。\n自然选择也许类似于工程，倾向于原则简单而可控的部件和规则，避免过度的复杂性。\n而复杂的高等动物则是自然选择的搜索过程中的一些随机采样的结果，因为没有引入缺陷而保留了下来。\nFundamental Physics 能否抛开现有的物理体系使用简单程序构建起新的物理体系。\nThe Notion of Reversibility 只有一少部分细胞自动机是可逆的，但是系统仍然展示了高度的复杂性。\nIrreversibility and the Second Law of Thermodynamics 粒子物理可逆但是很多自然现象不可逆，并且演变的越来越随机越复杂。\n根据简单程序模拟，越来越复杂是因为初始情况设置的简单。\n自然现象的初始情况都很简单，是因为初始情况的计算复杂性应该要小于实验过程。\n如果系统产生了足够的随机性，可以认为它们之间的趋同使得它们的属性跟初始条件无关。 这使得现在我们可以使用很少的参数来近似表示一些物理系统。\n但是自然中，尤其是生物系统存在一些不遵热力学第二定律，即越来越复杂的系统，否则宇宙就变得趋同了，而不是现在这样多样。\n根据37号自动机观察所得，热力学第二定律不是普适的。 宇宙持续变大，一些信息被忽略，自成一个有组织的小系统独自发展，然后相互重复。\nUltimate models for the universe 根据本书发现，宇宙的终极模型可能依赖于简单的规则。\n如何发现这个规则呢？根据物理现象推倒超出计算能力范围，因此试图遍历所有可能的简单模型看能否产生想要的宇宙的结果。\n现在发现的规律很可能都是终极模型的表象。\nThe nature of space 宇宙空间很可能是离散的。而过去一直认为是连续的，因为传统数学善于计算这种模式。\nSpace as a network 空间可能是由节点网络构成的。\n节点的距离和网络的维度有关。\nThe relationship of space and time 现代物理倾向于认为时间和空间本质相似，是时空第四维。 但是时间和空间的相似性很可能是不够小的实验数据导致的。 探索后作者发现在最本质上时空分离，就像元胞自动机的演化。\nTime and causal metwork 时空很可能是一种mobile automaton或图灵机，一次之更新一个单元。\n但是对于图灵机内部的单元来说，他察觉到变化时已经更新了一轮，因此感觉不到一次只更新了一个。\n我的结论 我就看到这里为止了，总的来说提供了一种新颖的离散化的思想。 世界就是一种巨大的计算机，谁都曾经这么想过，但是Wolfram对其进行了更深入的探讨。 蕴含其中的是宇宙遵循着简单的规则，这和许多科学家是相同的。\n后面几章引用一下豆瓣的书评，留待以后补完。\n 9.Fundamental Physics 我认为这章的内容很重要，首先，我们要有一个信念：这个世界就是一个计算机，每一件事情都是计算。 在这个前提下，我们来看世界，怎样的宇宙才是从程序上最可行的呢？ 作者探讨了空间网络、因果网络等模型。 究竟宇宙是不是一太计算机，我们实际上不能证伪，但是如果从程序的角度出发，却发现我们可以从一个完全不同的角度得到很多疑难问题的解答。 在因果网络模型下，相对论、量子论等等都是系统涌现出来的一种结果。 如果这一切正确的话，我们自然能得到一个统一量子论和相对论的工具。 另外，本章提出来的时空观是非常关键的，因果网络是最本质的东西，时间和空间甚至都是涌现出来的现象。\n10.Processes of Perception and Analysis 讲述把细胞自动机应用到计算机科学、人工智能、信息处理等领域的具体方法。 视觉感知、加密解密、思维过程等等都有涉猎。\n11.The Notion of Computation 究竟什么是计算？在很早，丘奇图灵论题就指出，一切与图灵机等价的过程就是计算。 那么细胞自动机与图灵机那个更强呢？ 通过作者特别的证明（运用图形和说明，而不是数学推导），我们看到一类特制的细胞自动机可以模拟任何一台其他的细胞自动机，而且还能模拟图灵机以及其他的计算系统。 翻过来，图灵机和其他计算模型也都能模拟细胞自动机。 实际上能够执行通用计算的机器仅仅需要简单的规则，也就是101号细胞自动机。 作者认为101细胞自动机非常重要，因为它规则简单，而且能够模拟任意的复杂计算过程。\n12.The Principle of Computational Equivalence 本章提出了一个猜想：The Principle of Computational Equivalence，也就是计算等价性原理，作者认为宇宙的一却活动都是一种计算，而且能够完成复杂计算的过程都是等价于通用计算的，所以，原则上讲，细胞自动机110能够模拟任何一个复杂的计算过程。 作者当然也讨论了哥德尔定理、不可判定问题，认为对于第四类细胞自动机，我们除了运行它以外，根本无法判定它在未来的行为，即使在原则上，因为它是不可判定的问题。\n "
},{
	"uri": "https://dailydreamer.me/post/2016-03-07-difficult-conversation/",
	"title": "关键对话",
	"tags": ["读书笔记", "心理学"],
	"description": "",
	"content": " Difficult Conversation(关键对话)，是指让你感到害怕和焦虑的对话，比如家人间、情侣间的吵架，上下级间的工作安排等。 本书对这种对话进行了深入的剖析，将问题分解看透彻之后可以更好的处理这种对话。\nThe problem 关键对话的结构：\n What happend\n The feelings conversation\n The identity conversation\n  我们不能改变周围，但是能改变的是对待这些挑战的反应。\nWhat happend 不要一上来就认为你是对的，试图搞清楚对方的感知、解释和价值观。\n对方的意图可能很复杂，不要预先假定是坏的。\n不要一味责备对方，试图弄清楚双方对造成问题的贡献。\nFeeling conversation 情感是困难对话的核心。\nIdentity conversation 调整你的认知失调造成的困难感是最有技巧可学习的。\nShift to a learning stance What happend conversation Stop arguing about who\u0026rsquo;s right, explore each other\u0026rsquo;s stories. 每个人对故事的解读都是有道理的。 争吵阻碍了我们从他人的角度理解故事。\n为什么会有不同的故事解读：我们注意到的和获取到的信息不同。 我们有不同的解读，受过去经历和隐含的规则的影响。\n对他人的故事感到好奇。\n有时候了解对方的立场不代表一定要同意，比如提出分手的时候，承认双方的立场。\nDon\u0026rsquo;t assume they mean it: disentangle intent from impact. 我们假设别人的意图通常是错的。\n试图去理解自己复杂的意图会给对方传递积极和在乎的信号。\n将你的意图告诉对方，试图弄清楚你的行为对对方的影响。\nAbandon blame: map the contribution system blame是关于judging但是contribution是关于understanding并且looking forward。\n提问我们各自做了或没做什么导致了这种结果，可以如何改进。\n在此过程中分享情感是必要的。\n四个容易忽略的错误：avoiding until now. being approachable. 忽略了每个人都很不一样。problemic role assumptions.\nThe feeling conversation Have your feelings 情感是关键对话的核心。\n不应该抛开情感只谈问题解决。\n找到你的情感，和情感协商，然后分享真实的感受。\n理解情感很困难，受到原生家庭的很多错误影响。\n责备可以成为你探寻更深层次情感的线索。\n情感是基于感知的，感知可以协商，因此情感也可以协商。\nthe identity conversation Groud your identity: ask yourself what\u0026rsquo;s at stake 核心认知：我有竞争力么？我是好人么？我值得爱么？\n错误的认知：all or nothing\n找到你的不稳定的认知，然后对它有清楚的认识。\ncreate a learning conversation What\u0026rsquo;s your purpose? When to raise it and when to let it go 发起关键对话之前先思考：你们之间是否真的有矛盾？是否有比发起对话更好的解决方法？你的目的是否合理？\nSometimes just let it go.\nGetting start: begin from the third story 我们通常从自己的故事开始，但是这会很不愉快。\n从第三方视角的故事开始。\nRoad map 将原版的操作手册摘录如下~\nStep l: Prepare by Walking Through the Three Conversations Sort out What Happened. Where does your story come from (information, past experiences, rules)? Theirs?\nWhat impact has this situation had on you? What might their intentions have been?\nWhat have you each contributed to the problem?\nUnderstand Emotions. Explore your emotional footprint, and the bundle of emotions you experience.\nGround Your Identity. What\u0026rsquo;s at stake for you about you? What do you need to accept to be better grounded?\nStep 2: Check Your Purposes and Decide Whether to Raise the Issue Purposes: What do you hope to accomplish by having this conversation? Shift your stance to support learning, sharing, and problem-solving.\nDeciding: Is this the best way to address the issue and achieve your purposes? Is the issue really embedded in your Identity Conversation? Can you affect the problem by changing your contributions? If you don\u0026rsquo;t raise it, what can you do to help yourself let go?\nStep 3: Start from the Third Story Describe the problem as the difference between your stories. Include both viewpoints as a legitimate part of the discussion.\nShare your purposes.\nInvite them to join you as a Partner in sorting out the situation together.\nStep 4: Explore Their Story and Yours Listen to understand their perspective on what happened. Ask questions. Acknowledge the feelings behind the arguments and accusations. Paraphrase to see if you\u0026rsquo;ve got it. Try to unravel how the two of you got to this place.\nShare your own viewpoint, your past experiences, intentions, feelings.\nReframe, reframe, reframe to keep on track. From truth to perceptions, blame to contribution, accusations to feelings, and so on.\nStep 5: Problem-Solving Invent options that meet each side\u0026rsquo;s most important concerns and interests.\nLook to standards for what should happen. Keep in mind the standard of mutual caretaking; relationships that always go one way rarely last.\nTalk about how to keep communication open as you go for- ward.\n"
},{
	"uri": "https://dailydreamer.me/post/2016-01-13-power-of-myth/",
	"title": "神话的力量",
	"tags": ["读书笔记", "哲学"],
	"description": "",
	"content": " 前些年读过的一本很神奇的书，记下一些富有力量的话语，有机会要重新温习。\n善与恶 善恶是相对于你的立场而定的。 对某人来说是善，对其他人可能就是恶。 但对上帝而言，二者并无不同。 你扮演着自己的角色，即使在你了解他有多可怕后也不退缩，而能把它看成是神秘超越而美妙惊奇世界之前奏。\n生命最大的挑战之一，就是肯定你心里最讨厌的人或事。 你不能说不应该有毒蛇，因为那是生命的本来面目。 但是在行动中，假如你看到毒蛇咬人，你会杀了他。 那并不是否定蛇，而是对那个情景说不。\n这两句话从更高的层面看待了善与恶的相对性。 每个人都有着自己的使命与愿景，与你相顺的于你即善，与你相逆的于你即恶。 知道没有绝对的善与恶是成熟的标志。\n人生的态度 生命一切皆苦，顺其自然，便是喜悦。 但是顺其自然，并不代表自暴自弃随波逐流，这不是必然的结论。 你将参与人生这场游戏，竭尽所能。\n不论你在何处，只要遵循你内心直觉的喜悦，你就可以享受到永恒生命之泉的那份清新，它一直在你内心的生命中。\n这世界上许多人都不曾停下来，倾听自己或邻人，学习什么是该做的，和什么是他们的生活价值。 对物质的追求是无止境的，但你终将在40岁意识到你已到达人生的巅峰，只有走下坡路的日子可活而陷入深深的忧虑。\n你只有一生可活，你不需要为他人而活，要活的专注，遵循内心直觉的喜悦。\n这几句话曾经同银他妈，以及后来读到的尼采的永劫回归理论，一起深刻的影响了我的人生抉择。遵从内心的喜悦吧。\n神话在今天的意义 艺术家是今日的巫师。而作为普通人，我们应该读书来理解自然的神性。 读对的人写的书，你的心就会被带到某个层次，你可因此而拥有一种美好，温和，慢慢燃烧的喜悦。\n不同的个体本是一体的，你们本来就是一个生命的两面，当下的分隔，只不过是在时空条件下，体验形体的方式结果罢了。我们的真实在于与所有的生命结合一致。 这个形而上的真理，可以在危机之下立刻体验到。因为它就是你生命的真理。\n整本书读完后，可以感受到神话不只是过去的故事，而是人类祖先古老的共同记忆和模范； 而今天的生活中，虽然不再相信神话表面描述的故事，但是其内涵却依然深深的烙印在我们心底，一直发挥着作用。\n"
},{
	"uri": "https://dailydreamer.me/post/2015-11-23-meet-ctf/",
	"title": "一次与CTF的邂逅",
	"tags": ["编程", "系统安全"],
	"description": "",
	"content": " 机缘巧合做了两道CTF二进制题目，谨以此为记。\n第一题 recho 主要参考这篇博客，ruby实现，也有人推荐了这篇python实现版，使用了pwntools。\n第一题中handle()函数buf大小256Byte，但是recv_line()函数接受用户输入没有限制长度，存在BOF漏洞可以利用。\n为了方便本地调试，将源代码中关于drop_priv()相关函数去除后，本地编译。\n为了能够在64位linux上编译和执行32位文件，需要安装32位环境。以Ubuntu14.04为例，执行\nsudo dpkg --add-architecture i386 sudo apt-get update sudo apt-get install libc6:i386 libncurses5:i386 libstdc++6:i386 gcc-multilib  即可。\n编译时使用命令\ngcc -fno-stack-protector -g -o recholocal -m32 recholocal.c  注意使用-m32参数编译成32位，-fno-stack-protector关闭stack canary检测，-g方便gdb调试。\n运行./recholocal后通过命令\nps -aux | grep recholocal  查看其进程号，通过\ngdb atach pid  来调试该进程。\nset follow-fork-mode child  可以使gdb在程序fork()后跟随子进程。\n在程序中找到recvline()和sendlen()，使用\nobjdump -d recholocal | grep recvline  获取地址，使用他们来对内存进行写和读。 注意recv_line最后以\\n结束。 还有程序最开始调用的sendstr()函数会将是将payload的strlen()长度发送，如果payload中有0x00就会被截断发送。\n使用objdump -x recholocal可以查看各个section的位置和布局，找到一个可读可写又足够大的section来存放我们的字符串参数，如.bss或.dynamic等。 发现.dynamic的位置是0x0804a10c。\n为了对付ALSR，需要先知道libc中某个函数的运行时地址，使用sendlen()将其发送过来，再加上system()相对这个函数的偏移，写入某个函数got表项，在调用该函数就是相当于调用了system()。\n使用\nobjdump -R recholocal | grep __libc_start_main  发现__libc_start_main()的got表项地址为0x0804a040。\nldd recholocal  可发现本地链接库libc.so.6的位置，对其objdump后找到__libc_start_main()和__libc_system()的地址，计算其偏移。\n使用objdump -d recholocal | egrep 'pop|ret'发现ppppr如下\n8048d1c:\t5b pop %ebx 8048d1d:\t5e pop %esi 8048d1e:\t5f pop %edi 8048d1f:\t5d pop %ebp 8048d20:\tc3 ret  在堆砌堆栈时需要使用，使用时截取需要部分即可。\n本地跑通后将地址改为服务器端地址即可。\n刚开始本来想利用这篇博客中的方法获取reverse shell，后来发现由于recho程序中将标准输入输出都复制到了socket中，所以只需cat ～/flag然后再read()出来即可。\n第二题 weapon_shop 这一题只有二进制文件，先使用IDA Pro反编译，按F5可以看到部分C伪码，结合程序对函数进行理解。\n可以看到该程序输入时都限制了长度，因此不方便BOF。 但是找到在输入Credit Card Number时长度限制为200Byte，而且写入了可执行的.bss段，因此可以在这里写入一些shellcode，地址为0x0804b1e0。\n同时注意到在买武器过程中输入数字，使用了strtol()函数，它会扫描字符串，跳过前面的空格，将后面的字符转换成数字。而函数只检查了第一个字符不是负号，以及不大于8，因此可以输入空格加一个任意负数。 后面它使用数组起始地址加这个数得到的地址对其自增，因此输入一个合理的偏移量就可以对任意高于该数组起始地址的地址进行自增。 该数组位于主循环函数的栈上，因此可以对主循环函数的返回地址改写位shellcode所在的地址。 注意该自增只增加一个字节，因此需要对返回地址每个字节分别自增。\nshellcode最后选取了拿到/bin/sh的shellcode。 因此最后使用了pwntools里的interactive()函数和远端shell进行交互。\n"
},{
	"uri": "https://dailydreamer.me/post/2015-10-30-ssh-config/",
	"title": "多个github账号的ssh key切换",
	"tags": ["编程", "ssh"],
	"description": "",
	"content": " 当拥有多个github账号并且想通过ssh方式同步代码时，就需要在多个账号的ssh key间切换。\ngithub多个账号ssh key切换 配置ssh的config文件 使用ssh-keygen -t rsa -C \u0026quot;youremail@xxx.com\u0026quot;生成两个ssh key之后，在~/.ssh/下添加一个config文件，内容如下:\nHost github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa Host second.github.com HostName github.com PreferredAuthentications publickey IdentityFile ~/.ssh/id_rsa_second  设置远程仓库的ssh地址 只需要让ssh的目标主机地址变为你写的Host即可。\ngit remote add origin git@second.github.com:myname/myrepo.git  更加深入的利用ssh config文件可以参考这篇文章。\n"
},{
	"uri": "https://dailydreamer.me/post/2015-08-04-zen-and-the-art-of-motorcycle-maintenance/",
	"title": "禅与摩托车维修的艺术",
	"tags": ["读书笔记", "哲学"],
	"description": "",
	"content": " 第三章 科学就是现代的鬼神。 过去人们使用鬼神解释自然现象，现代人们使用所谓的科学来解释。 这些都只存在于人们心里，是对自然规律的一种认识和解释。\n第四章 一个世纪前和小孩一起读古典的方式：读两句话，等他一连串的提问，然后回答他的问题。\n第六章 使用二分法，将人类的认知分为古典的和浪漫的。 古典的认知认为这个世界是由一些基本形式组成的；浪漫的认知则从表象来观察，主要的是情感而非事实。\n斐德洛的古典中有名为分析的小刀。\n第七章 我们选择性的筛选出感官接受的结果，浪漫的认知直接针对这个结果，而古典的认知使用分析的小刀对其进行分类，并且注重相互之间的联系。\n第八章 摩托车的外观是浪漫的，但是内在的运作是纯古典的。 他的外壳就是古典和浪漫的分界。\n摩托车也是一种系统，正如政府和军队。 只要架构系统的理性还在，系统就可以被轻易重新构建。\n第九章 逻辑使你在系统中找到自己的路。逻辑有归纳法和演绎法。 两种方法交替使用就能解决问题。\n第十章 前面铺垫了那么多，这一章开始渐渐接近了问题的核心。\n在科学的殿堂中有许多深宅大院。 有的人倾心科学是因为优越的智力，有的人则完全为了实用的目的。 如果上帝派来的天使将上面两种人从殿中驱逐出去，那么殿里会空旷许多。 那些获得天使青睐的人，有些古怪、沉默和孤独，除了同是不受欢迎的人外，彼此之间少有相似之处。 斐德洛认为自己就是这样的人。 所以当他提出科学困扰他的问题时，没有人真正关心。于是他开始了心灵探索的道路。\n困扰他的问题是什么呢?\n科学研究，或者说自然科学的研究，是通过观察现象做出假设然后实验证明得出结论。 爱因斯坦认为，根据进化论所显示的，在历史上任何一刻，所有可想见的存在，总有一个会证明它比其他一切要优越。 但是斐德洛认为现在由于眼界的广阔，假设出现的速度远大于验证他们的速度，因此科学真理持续的时间越来越短，很容易被后来验证的假设推翻。 各种假设和定理的增加，把人从唯一绝对的真理，引向多元、摇摆不定、相对的世界，是造成社会和思想价值混乱的元凶。 现在的理性结构不符合社会所需，然而在情感上空虚，在美学上没有任何表现。 造成社会上一些人在整个文明的理性架构下，活的盲目而疏离，找寻不到答案。\n我以为因为斐德洛是搞生物化学的，如果他从事过数学研究就会发现这个所有自然科学的根基是一门注重概念的演绎科学，不是使用实验证明假设，而是靠演绎。 依靠最底下的公理构建起整个大树。 每当物理学家走的飞快依靠直觉提出各种假设，数学总是跟在后面谨慎的证明。 虽然偶尔出现过改变公理构建出不同大树的情况，但总体上没有这个问题。 壮哉我大数学~\n第十一章 斐德洛通过哲学探索人类心灵的高山地带。\n大卫·休谟的经验主义，认为我们的知识都来自于感官。 但是会得出推论说整个世界出自于人的想象。\n康德试图推翻经验主义。 他认为我们人性之中有一种直觉，我们认为的现实，是直觉和感官接收到的讯息融合而成。 我们通过感官接收到的讯息不断修正直觉，直觉也在过滤着感官接收到的讯息。\n斐德洛认为康德的《纯粹理性批判》中有着属于理性自身的丑陋。\n第十二章 斐德洛之后去了印度研究东方哲学，他的知识在那儿出现了混乱。 他离开了印度，放弃了对理性的追求，念了新闻学位，结婚生子。\n放下了之后，反而成熟的更快。 于是他变成我们的作者又开始继续追寻，通过这次旅途。\n第十三章 斐德洛说，真正的大学是心灵的世界，是多少世纪以来流传给我们的理性思想，大学的本质在于通过教授们流传下来的理性自身。 物质的大学只是为真正的理性教会提供了生存的环境。\n斐德洛因为对科学理性缺乏信心，所以才成为了理性教会的狂热研究者。\n第十四章 科学没有和人的心灵连在一起，所以在盲目之中暴露出了丑陋的一面。 解决的方法不是抛弃或否定理性，而是扩展理性的内涵。\n哥伦布发现新大陆时也拓展了整个文化的根基，当时人们抛弃了中古世纪的价值观，接受理性的新世界。\n第十五章 重返斐德洛教书的地方，探寻良质的意义。\n第十六章 良质的第一部分，模仿是一种罪恶。 是学校的教育造成了这一点，他试图取消分数和学位制度，但是并没有得到好的结果。\n第十七章 良质是说一篇优秀的作品不需要任何规则，不需要任何理论，然而他指向某种东西，非常真实。 不是模仿，而是內驱的创造。\n第十八章 不去界定良质，不用理性去分析良质。使用理性来支持这一观点。\n如果剥离良质，世界将不能正确运转，不值得活下去，因此良质是存在的。\n良质同时存在于古典和浪漫两个世界中。由于没有定义，古典被迫用浪漫的观点去看良质。\n第十九章 良质既不属于人心的一部分，也不属于物质。\n良质就是同时意识到主客观存在时所发生的事件。\n第二十章 \u0026ldquo;过去\u0026rdquo;只存在于我们的记忆之中，\u0026rdquo;未来\u0026rdquo;则存在于我们的计划之中，而只有\u0026rdquo;现在\u0026rdquo;才是惟一的真实。 你理智上所意识到的那棵树，由于这一小段的时间的关系，便属于过去，因而对你来说并不真实。 任何经由思想所意识到的总是存在于过去，因而都不真实。 所以真实总是存在于你所看到的那一刹那，且在你还没有意识到之前。除此之外，没有别的真实。 这种在意识之前的真实，就是斐德洛所谓的良质。 由于所有经由思想所认知的事物必须来自于这一段思考前的真实，所以良质是因，而果才是所有的主体以及客体。\n如果我们想用我们所创造的世界去涵盖、去刺激我们创造的源头，这是不可能的。 这就是为什么良质无法被界定，如果我们去界定，我们所界定的就无法涵盖整体的良质。\n第二十二章 彭加列说，“潜意识自我”注视着一个问题的一大串解决方案，但是只有有趣的可以闯进意识领域内。 数学解答是由潜意识自我所选择的，是基于“数学之美”，数字与形式的和谐，以及几何学的优雅。 彭加列说，这是一个所有数学家都知道的真实的美感，可是世俗者对此是如此无知以至于经常想笑。 但是这和谐、这美丽，是它整个的核心。\n上面一段话我理解为这就是数学的良质。 作者将数学证明中创造性的部分归结为良质这一更加基本的概念，十分的新奇。\n事实的预先选择并不是基于主观的、反覆无常的\u0026rdquo;任何你喜欢的东西\u0026rdquo;，而是基于良质，即实在自身。良质区别于主观和客观之外。\n第二十四章 如果科技的根本问题在于，科技专家或是反科技的人都缺乏关心之情； 而且，如果关心和良质是一体的两面，那么我们就可以推论出，今天在科技上出现的根本问题，就在于学科学的人和反科学的人，都缺乏在科学上洞悉良质的能力。\n一个人在修理摩托车的时候，对车子的了解分分秒秒都在改变，因而得到了全新认识，其中蕴含了更多的良质。修理的人不会受限于传统的做法，因为他有足够理性的基础拒绝这些思想。 真实不再是静态的，它不是让你决定是要去奋战还是打退堂鼓的思想，它们是会跟着你成长的思想。 所以具有良质的真实，它的本质不再是静态的。\n第二十五章 如果你想要高水准的表现，就必须具备鉴赏力以及达到目标的方法，也就是同时具有对良质的古典和浪漫的认知。\n只有内心宁静，我们才能察觉到良质的存在。他超越了浪漫和古典的认知，将二者融合为一。\n第二十六章 进取心，希腊人称之为热忱。 以及其中的一些陷阱。\n第二十七章及之后 阐述了斐德洛和作者融合成长的心路历程，最后完成了对自己的救赎。\n我的总结 现在由于自然科学研究方法的问题，导致真理持续的时间原来越短，价值观变得多元化了。 这时候就需要人们意识到除了古典和浪漫之外的良质，即对自己所做事务有一种热忱和鉴赏力，同时能够有做好他的技术，这样才不会造成价值观的混乱和生活的疏离感。 感觉此时的中国和上世纪的美国面临着类似的问题，人们缺乏信仰，生活无价值无意义，盲目拜金等等问题，都是价值观混乱的表现。 而作者通过自己内心之路的探求，提出了一种基于良质的解决方法，虽然道理容易理解，但是思考的过程十分严谨，令人信服，感觉收获颇丰。\n"
},{
	"uri": "https://dailydreamer.me/post/2015-07-25-product-manager/",
	"title": "人人都是产品经理",
	"tags": ["读书笔记", "产品经理"],
	"description": "",
	"content": " 写给-1到3岁的产品经理 我们到底是不是产品经理 产品是可以满足人需求的载体，商业产品在用户需求和商业目标之间平衡。\n宝洁产生了产品经理的概念。\n传统产品经理是品牌经理或产品市场经理，重在营销。\n   Type 典型的传统行业 互联网、软件行业     行业形态 成熟行业 新兴行业   产品形态与成本结构 实物 虚拟物品   生命周期 几年 几个月   盈利模式 单一卖产品赚钱 多元盈利   用户心态 花钱买 免费用    互联网软件行业产品创新多，产品经理注重产品功能规划。\n产品多为虚拟物品，因此注重需求分析和设计细节。\n产品生命周期短，产品经理在项目完成度和产品质量间做平衡。\n盈利模式更多元，靠用户数量，产品经理重视用户研究和用户需求。\n用户免费用，更换成本小，用户是上帝，重视用户体验。\n管理是在资源不足的情况下把事情做成的能力。而资源不足是常态，因此你已是产品经理。\n我真的想做，怎么入行 喜欢做产品，并且不是站在用户角度，而是站在产品经理角度看待产品。\n研究产品经理招聘广告并总形成调研报告。\n一个需求的奋斗史 用户研究-\u0026gt;需求采集-\u0026gt;需求分析-\u0026gt;需求筛选-\u0026gt;需求管理。\n需求采集的大生产运功 明确目标，明确采集方法，制定采集计划，执行采集，资料整理，然后进需求分析。\n定性的说：用户访谈。\n 为避免说的和做的不一致，可以尽量在用户和产品交互的场合下进行。\n 要避免样本少，以偏概全。\n 牢记访谈目的，不要太强势，也不要被用户代跑。\n 避免一组固定的问题。这会让用户有被审问的感觉。\n 首先关注目标，任务其次，多问为什么这么做。\n 避免让用户成为设计师，用户的解决方案通常短浅片面(这个深有体会。。。)。\n 避免讨论技术。\n 鼓励讲故事。\n 避免诱导性的问题。\n  定量的说：调查问卷\n用户访谈通常是开放性问题，调查问卷则是封闭式。\n作答时间最好不要超过10分钟。开篇简单问题，需要思考的在中间，个人信息在最后。\n 样本和目标群体可能有偏差。\n 样本不能过少\n 问卷内容应该无引导性。答案的顺序也会对答案产生影响。\n  定性的做：可用性测试\n是UGC(用户产生内容)的实践。让用户使用原型产品发现设计中的可用性问题。\n 可用性测试不能太晚。\n 明确是测试产品，不是测试用户。\n 可以使用Think aloud方法。\n 一切错都是产品和我们的错。\n  定量的做：数据分析\n 不要过于学术，讲究性价比。\n 不要误读数据。提高统计水平；不要为了迎合某个观点取找数据。\n 平时注意收集数据。\n  需求采集人人有责 从用户得到的一手需求，从销售和老板得到的二手需求。\n单项需求卡片。\n尽可能多的采集：现场调查，AB测试，卡片分类，自己提需求。\n听用户的但不要照着做 明确我们存在的价值：将用户需求转化为产品需求。\n需求分析是一个分总分的过程，先透过用户需求看到本质，然后将本质分解为产品需求。\n满足需求的三种方式，直接满足、降低理想、转移需求，最高境界是创造需求。\n需求分析步骤：需求转化，确定基本属性，分析商业价值，初评实现难度，计算性价比。\n性价比 = 商业价值 / 实现难度。\n活下来的永远是少数 初创团队适合安产品线划分，产品经理权力大，单个产品得到保证；成熟企业适合按职能线划分，增加资源共享与团队交流学习。\n商业需求文档：项目背景、商业价值、功能需求描述、非功能需求描述、资源评估、风险和对策。\n少而精，吹走漏肥皂盒的故事。\n项目坎坷的一生 从产品到项目 产品是解决问题的东西，项目是一个过程，产品要一个个项目来实现。\n产品经理靠想，做正确的事情；项目经理靠做，把事情做正确。\n产品体验和项目难度的权衡。\n一切从Kick off开始 团队组建、时间计划、沟通方式、誓师大会。\n关键的青春期，又见需求 商业需求文档、市场需求文档、产品需求文档、功能详细说明。\n成长，一步一个脚印 需求评审过后进行需求冻结。\n山寨级项目管理 逐步建立自己的文档模板库。\n逐步建立流程，就是把经常做的事情的好的方法固化下来。\n我的产品，我的团队 大产品，大设计，大团队 所有和产品有关的事都是产品经理的事。\n产品之大 时间之大——产品生命周期：\n不同时期的产品和市场用户都有其特点，最佳状态是彼此的完美配合。\n空间之大——商业、产品、技术\n公司的DNA：腾讯是产品主导，Google曾经是技术主导，阿里巴巴曾经是商业主导。\n设计之大 本能水平设计，能满足用户需求；行为水平设计，好用，交互便利；反思水平设计，情感化设计。\n团队之大 随着团队变大，分工要渐渐明晰，让各种人与各种事匹配。如客服到PD的接口人。\n职能型组织和项目型组织，以及结合两者的矩阵型组织。\n游走于商业和技术之间 心思缜密的规划师，狭义的产品团队。\n激情四射的设计师，精雕细琢的交互设计与敏捷开发的权衡取舍。\n阴险狡诈的运营师。\n商业团队，冲锋陷阵 版本细分的策略：做功能区分，打细分市场；策略性做出“炮灰版”。\n技术团队，坚强后盾 如何与工程师合作：制定规则。如需求变更的流程。\n容易被遗忘的角落 最好的资源：老板。让老板做问答题-\u0026gt;让老板做选择题-\u0026gt;让老板做判断题。\n大家好才是真的好 产品经理的无授权领导：不为我所有，但为我所用。\n既要领导，也要管理。\n让团队开心，小礼物和团队活动。\n别让灵魂更不上脚步 触及产品的灵魂 应该做什么：以价值观为根基。\n价值观、使命、愿景。在此之上构筑公司战略。\n可行性分析三部曲 我们在哪儿：市场扫描(PEST)，竞品分析($APPEALS)，自我分析(SWOT)。\n我们去哪儿：细分市场、目标用户、满足什么需求。\n做吧，准备出发 产品的路标规划。\n不要试图在一个会议中解决很多问题。\n大会决定小事 小会决定大事。\n要想会议不流于形式，就把会议变成形式，会前做好关键人员的沟通。\n罗伯特议事规则。所有人提意见，少数人讨论，一个人拍板。\n会议记录，重点是会议决议与遗留问题。\nKPI!KPI!KPI! smart原则：具体，可度量，可实现，现实性，有时限。\n远视者把目的当手段，近视者把手段当目的。\n短期目标与长期目标的权衡，如成绩中上的同学比成绩最好的有出息。\n本书的源头活水 产品经理的自我修养 爱生活让我们充满动力，有理想让我们目标明确，会思考让我们方法得当，能沟通让我们团队前进。\n爱生活才会爱产品 电子菜单用来数据收集和个性定制。\nwindows回收站当文件夹。。。\n有理想，就不会变咸鱼 战略是公司的灵魂，理想是人的灵魂。\n要做的事，想做的事，能做的事重合。\n个人品牌建设。\n会思考，活到老学到老 注重方法和知识的积累。\n能沟通，在什么山头唱什么歌 销售卖产品，PD卖想法。\n沟通不是为了说服，而是为了更好的认识世界。\n产品经理主义 为什么做，第5章战略。\n做什么事，解决什么人的什么问题，第2章需求。\n何时做、谁来做，第3、4章项目和团队。\n"
},{
	"uri": "https://dailydreamer.me/post/2015-06-29-hiding-mouse-globally-in-wpf/",
	"title": "WPF全局隐藏鼠标",
	"tags": ["编程", "编程语言"],
	"description": "",
	"content": "前些日子使用WPF实现了一个填平两个屏幕间缝隙的小程序，在那里面需要让光标在两个屏幕间的时候将其隐藏。 在一个程序内部隐藏鼠标很容易，在WPF中只需设置Mouse.OverrideCursor = Cursors.None。 但是当程序最小化后鼠标还能隐藏着实费了一番功夫。 大致有如下几种思路。\n 将系统的光标图标设置为一个blank.cur的空图标，要显示时再替换回来，这样就可以全局隐藏鼠标，具体方法可以看这里。 但是这种方法有一些问题，一个是需要将系统所有状态的光标图标都替换为空图标，十分繁琐； 而且非常危险，因为一旦你的程序在隐藏鼠标时崩溃，那么鼠标就消失了！ 只有重启才能重新显示鼠标。\n 要隐藏鼠标时将鼠标的位置一直设置在右下角。 这样虽然看不见鼠标了，但是有时会触发侧边栏，尤其是Win8的右边栏； 同时无法知道用户此时已经将光标移动到哪里了，因此也不是非常好用。\n 最后终于找到了一种十分讨巧的方法。 就是在要隐藏光标的范围内新建一个透明窗口，然后在这个窗口上将光标隐藏。 大致代码如下：\n  Window cursorWin; private void cursorWinInit() { cursorWin = new Window(); cursorWin.Left = bound - (W + hideBuffer); cursorWin.Top = 0; cursorWin.Width = 2 * (W + hideBuffer); cursorWin.Height = maxHeight; cursorWin.ShowInTaskbar = false; //禁止在任务栏显示 cursorWin.WindowStyle = WindowStyle.None; //无边框 cursorWin.AllowsTransparency = true; //透明 cursorWin.Topmost = true; //置顶 cursorWin.Background = new SolidColorBrush(Color.FromArgb(1, 0, 0, 0)); //透明 } private void myHideCursor() { cursorWin.Dispatcher.Invoke( new Action( delegate { cursorWin.Show(); Mouse.OverrideCursor = Cursors.None; })); } private void myShowCursor() { cursorWin.Dispatcher.Invoke( new Action( delegate { cursorWin.Hide(); Mouse.OverrideCursor = null; })); }  "
},{
	"uri": "https://dailydreamer.me/post/2015-06-28-unix-programming-art/",
	"title": "UNIX编程艺术",
	"tags": ["读书笔记", "编程"],
	"description": "",
	"content": " 这本书极为经典，虽然后半部分的细节有些过时，但是前面的哲学影响深远且富有启发性。\n哲学 UNIX有它独有的文化和哲学，它富有生命力且影响深远。UNIX诞生于1969年，而今天化身为Linux、BSD、MacOS X等，应用广泛且强大。\nUNIX文件在字节层次上再无结构，文件删除了无法恢复，作业控制有欠精致，命名方式混乱。这些都是UNIX的缺点。\n最大的争议在于，提供机制，而不是策略。 比如X Window，提供一套极端通用的图形操作，将界面的观感(策略)推后到应用层。 这使得UNIX可以提供很多行为选项和令人眼花缭乱的定制功能。 然而它的代价就是当用户“可以”设置自己的策略时，他们“必须”设置自己的策略。 这使得UNIX失去了很多非技术用户，但是策略相对短寿，机制才会长存。 只提供机制才能使得UNIX长久保鲜。\n同时，UNIX还有着及其丰富和优秀的外围文化。 开源软件，跨平台可移植和开放标准(IEEE的可移植操作系统标准POS很快被大家加后缀变成了POSIX)，Internet和TCP/IP协议，开源社区，从头到脚的灵活性(在其他系统中，完成设计者预见的任务容易，但是设计者没有预料到的就很难)，以及UNIX hack很有乐趣。\nUNIX哲学起源与Ken Thompson早期关于如何设计一个服务接口简洁、小巧精干的操作系统的思考，一路成长且博采众长。 UNIX管道的发明人Doug Mcllroy总结，UNIX哲学是一个程序只做一件事，并做好。程序要能协作。 程序要能处理文本流，因为这是最通用的接口。整体上，UNIX哲学可以概括为一下几点：\n 模块原则：使用简洁的接口拼合简单的部件\n编制复杂软件而又不至于一败涂地的唯一非方法就是降低其整体复杂度，用清晰的接口把若干简单的模块组合成一个复杂的软件。\n 清晰原则：清晰胜于机巧\n些程序时，要想到你不是写给计算机看，而是写给人看的。优雅而清晰的代码不仅不容易崩溃，而且更易于让后来的修改者立刻理解。\n 组合原则：设计时考虑拼接\n在输入输出方面，UNIX传统极力提倡采用简单、文本化、面向流、设备无关的格式，否则很难和其它程序衔接。要想让程序具有组合性，就要使程序彼此独立。\n 分离原则：策略同机制分离，接口同引擎分离\n策略短寿，机制长存。在探索新策略的时候尽量不要打破机制，这样也可以为机制编写更好的测试。\n在GUI之外也可以应用这个原则，如Emacs编辑器使用内嵌的脚本语言Lisp解释器来控制用C编写的编辑原语操作。\n 简洁原则：设计要简洁，复杂度要低\n复杂的东西代价更高，bug更多。以简洁为美，总设法将程序系统分解成几个能够协作的小部分。\n 透明性原则：设计要可见，以便审查和调试。\n透明性是说一眼能看出软件是在做什么以及怎样做的，显见性是说程序带有监视和显示内部状态的功能。尽早设置调试选项。\n 健壮原则：健壮源于透明与简洁\n健壮性指在超出设计者预想外的条件下也能运行良好。\n 表示原则：把知识叠入数据以求逻辑质朴而健壮。\n数据比变成逻辑更容易驾驭。主动将代码的复杂度转移到数据之中去。\n 通俗原则：接口设计避免标新立异\n 缄默原则：如果一个程序没什么好说的，就保持沉默\n只输出重要的东西。\n 补救原则：出现异常时，马上退出并给出足量错误信息\n“宽容的收，谨慎的发”。\n 经济原则：宁花机器一分，不花程序员一秒\n 生成原则：避免手工hack，尽量编写程序去生成程序\n 优化原则：雕琢之前先有型\n先制作原型，再精雕细琢。从原型中寻找通过牺牲最小局部简洁性而获得较大性能提升的地方。\n 多样原则：绝不相信所谓“不二法门”断言\n 扩展原则：设计着眼未来，未来总比预想的快\n一言以蔽之，就是KISS，Keep it simple and stupid。\n  历史————双流记 忘记过去的人，注定要重蹈覆辙。\n对比：UNIX哲学同其他哲学的比较 UNIX风格，一切皆文件，以及在此之上的管道概念。\nUNIX中，进程生成代价低，并且有简便的进程间通讯。使得众多小工具、管道和过滤器组成了一个均衡系统。 而反UNIX系统必须编写庞大的单个程序，并且进程间通讯要知晓彼此的细节，否则就只能采取低效不安去的方式。\nUNIX中内部边界清晰。 有多用户权限，以及把设计关键安全性的功能限制在尽可能小的可信代码块上。 即使shell也不是什么特权程序。\nUNIX文件不是靠后缀名识别的，没有文件属性，但是可以通过magic number来识别文件。 文件属性在管道中会引发棘手的问题，对文件属性的支持会使程序员使用不透明的文件格式。\n如果不像UNIX强调CLI命令行界面，那么程序设计不会考虑以未预料的方式合作，难以实现远程系统管理，守护进程难以实现。\nUNIX开发门槛很低，有大量廉价工具和简单接口，开创了轻松编程的先河。\n模块性，保持清晰，保持简洁 封装和最佳模块大小 模块太小时，复杂性全在于接口，阅读代码需要知道大量接口。模块太大时，模块内部代码bug太多。这都不是很好。\n紧凑型和正交性 紧凑性是指一个设计内否装进人脑，有经验的用户是否不需要手册。 不要有内部功能冗余，否则会出现功能子集成为“方言”，“方言”之间相互不能理解。\n正交性是说每一个动作只改变一件事而不影响其他。正交性缩短了测试和开发的时间。重构的原则性目标就是提高正交性。\n任何一个知识点在系统内都应当有一个唯一、权威的描述。\n围绕“解决一个定义明确的问题”的强核心算法组织设计，避免臆断和捏造。\n软件是多层的 纯粹自顶向下设计和自底向上设计都不好，可以结合使用。 但是需要胶合层来协调策略和机制。\nC语言作为结构汇编程序是薄胶合层的经典代表。 完美之道，不在无可增加，而在无可减少。\nUNIX强烈倾向于把程序分解成由胶合层连接的库集合。\nOO经常被过分推崇为解决软件复杂性的唯一方法，这违背了多样性原则。\nOO在其取得成功的领域(GUI，仿真，图形)之所以成功的主要原因之一是因为在这些领域里很难弄错类型的问题本体。\n文本化：好协议产生好实践 文本化的重要性 文本流非常通用，并且通过压缩文本可以有很好的性能。\n二进制格式限制了位数，文本可拓展性更强。\n数据文件元格式 尽可能使用元格式而不是标新立异。\nDSV，分隔符分隔值。如/etc/password用冒号分隔，反斜杠转义。\nRFC 822，电子邮件格式。HTTP1.1也是这种格式。属性每行一个，冒号接空白结束。\nCookie-Jar和Record-Jar，用%%\\n结束。\nXML，适合复杂数据格式，但是不能被传统UNIX工具解析。\nUNIX文本文件的约定：\n 如果可能，以换行符结束的每一行只存一个记录。\n 如果可能，每行不超过80个字符。\n 使用#引入注释。\n 支持反斜杠约定。\n 使用冒号或连续空白作为分隔符。\n 不要过分区别TAB和空格(令人头疼的python缩进)。\n 对于复杂的记录，使用节格式。使用%%\\n作为分隔符。并支持连续行(如Cookie-Jar)。\n 包含版本号，或将格式设计成相互独立的自描述字节块(如PNG)。\n 不要仅对文件的一部分进行压缩或二进制编码。\n  应用协议设计 //TODO 留着以后看。。。\n透明性，来点儿光 透明性是说知道程序在干什么，可显性是说知道程序怎么干的。\n优雅的代码不仅正确而且显然正确。优雅的代码不仅将算法传递给计算机而且将见解传递和信心传递给阅读代码的人。\n编写透明可显的系统节省的精力，将来可能就是自己的财富。\n为透明性和可显性设计 要追求代码的透明，最有效的方法很简单，就是不要在具体操作的代码上加上太多抽象层。\n可以默认隐藏细节，但不要使其无法被访问。\n反例，不透明的Windows注册表，注册表蠕变。\n为可维护性设计 选择简单的算法，提供开发者手册。\n多道程序设计：分离进程为独立的功能 做单件事并做好。\n真正挑战的不是协议语法而是协议逻辑。\n从性能调整中分离复杂度控制 除非万不得已(性能太差)尽量避免使用线程。\n将程序划分成多个子进程可以使需要特权的代码块尽量少。\nUNIX IPC方法分类 将任务转给专门程序。UNIX shellout。\n管道，重定向和过滤器。\n 管道中所有阶段程序都是并发执行的。\n 管道的缺点或局限是单向性。\n  包装器。\n 隐藏shell管线的复杂细节。\n 安全性包装器。\n  从进程。\n对等进程间通信。\n 临时文件。用文件名包含$$，即PID保证文件名唯一。\n 信号。需要信号的程序会向var/run写入pidfile。\n 套接字。\n 共享内存。\n  要避免的问题和方法 废弃的UNIX IPC方法。\n远程过程调用。不够透明可显。\n线程。同步互斥锁开销大且bug多。\n微型语言：寻找唱歌的音符 更高级的语言可以使用更少的行数完成更多任务，也意味着更少的bug。\nUNIX包容小型的、为专门领域特制、大量减少程序行数的语言。\n//TODO 留着以后看。。。\n生成：提升规格说明的层次 尽可能把设计的复杂度从代码转移到数据中去。\n配置：迈出正确的第一步 什么应该是可配置的 对于能够进行可靠检测的东西，就不要提供配置开关。\n提高程序适应能力，除非这样做会产生超过0.7秒延时。\n增加一个配置选项，就会减少测试覆盖率。\n配置在哪里 局部覆盖全局。\n使用同参数选项预期寿命最匹配的机制。\n命令行选项 传统UNIX风格如-ab。\nGNU风格如`--a --b\n接口：UNIX环境下的用户接口设计模式 最小立异原则。新颖性提高了用户与接口最初几次的交互成本。仔细掂量你的折衷。\n提倡以共生和委派策略提高代码复用，降低复杂度。\nUNIX接口历史。面向行的，面向字符阵列的，和基于X的。\n接口设计在这些条件间权衡：简洁，表现力，易用，透明，脚本化能力。\n现代接口应当既支持CLI又支持可视接口，它们各有优缺点。\nUNIX程序员愿意使接口富有表现力和可配置。\n接口设计模式：\n 过滤器：catlike型，宽进严出，不需要的也不丢弃，绝不增加无用数据。\n canstrip模式，如clear。\n 源模式，如ls。\n 引擎和接口分离。MVC模式。\n 基于语言的接口。\n 等等各种模式。\n  网页浏览器作为通用前端，避免了后端大量GUI冗余代码。\n优化 知道何时不去优化。\n最有效的优化往往是优化以外的事情，如清晰干净的设计。\n最强大的优化技术是不优化。摩尔定律的指数效应。不值得为常数项优化。\n先估量，后优化。明确瓶颈所在，使用性能评估工具。\n小即是美，尽量将核心代码和数据结构放进缓存。\n降低延时。可以批处理、重叠操作、缓存。\n复杂度：尽可能简单，但别简单过了头 谈谈复杂度 程序员在意实现的复杂度，用户在意界面或接口的复杂度，第三个标准是代码总行数。\n接口复杂度和实现复杂度需要折衷。\n旧学派UNIX唯一的框架就是重定向、管道和shell，而Emacs将非常多的文本缓冲区和援助进程同文件系统统一在一起，大大超越shell框架。\n选择需要管理的上下文环境，并且按照边界所允许的最小化方式构建程序。只有实证其他方法行不通时才编写大程序。\n语言：C还是非C C的内存管理是复杂性和错误的深渊。\n真实世界中的程序往往受I/O、网络等的影响远大于CPU的影响。\nshell即使一种最早的解释型语言，高级shell编程可以混合各个语言。\nC语言资源效率接近机器语言，但是编程是资源管理的炼狱。\nC++最佳之处是编译效率以及面向对象和泛型编程的结合，最糟之处是它太过怪异复杂，其设计者承认他不指望任何一个程序员能够完全掌握C++。\nshell最佳之处在书写小型程序自然快捷，不用安装，但是不适合大型程序，并且不好移植。\nPerl最佳之处是作为加强shell的强力胶合程序，但是Perl有些部分很丑陋。\nPython清晰易读，易学易用，容易和C结合，但是效率相对低下。\nJava移植性好，效率较高，面向对象，但是爹不好。。。\n工具：开发的战术 讲解了各种UNIX开发工具，但是太过陈旧了。\n重用：论不要重新发明轮子 透明性是重用的关键。\n开源后换工作也可以使用原来的代码。\n编写开源软件的人往往自己也使用，并且开源社区不会羞于抓bug。\n许可证问题 OSD，OSI Cerified Open Source认证标志的法律定义，是最好的自由软件定义。所有标准许可证都满足他。\nMIT，BSD，GPL，MPL等等。\n可移植性：软件可移植性与遵循标准 文档：向网络世界阐释代码 开放源码：在UNIX新社区中编程 开发源码的规则很简单：\n 源码公开\n 尽早发布，经常发布\n 给贡献以表扬\n  开源开发利用散布在互联网上，而且主要通过email和网络文档交流的大型程序员团队。一般有核心开发者或核心开发组来指导项目。\n代码质量很难判断，开发者通常通过提交质量来评估补丁。\n未来：危机与机遇 PLAN 9， 未来之路 所有挂载的文件服务器都具备相同的类文件系统接口。\nPLAN 9 失败了，说明更优秀方案的最危险敌人，就是一个现存的足够优秀的架构。\nUNIX设计中的问题 UNIX文件就是一大袋字节。\nUNIX对GUI支持孱弱。\n文件删除不可撤销。\nUNIX假定文件系统是静态的。Linux改进了这一点，具有文件和目录更改通知功能。\n作业控制设计拙劣。\nUNIX API没有使用异常。\nUNIX环境问题 UNIX文化问题 信任的理由 迄今为止，打赌UNIX玩家会输的人总是聪明一时糊涂一世。我们能赢————只要我们想赢。\n"
},{
	"uri": "https://dailydreamer.me/post/2015-06-23-python-yeild-and-parse-xml/",
	"title": "Python解析XML与生成迭代器",
	"tags": ["编程", "编程语言"],
	"description": "",
	"content": " 这次来看看Python解析XML与生成迭代器。\n迭代器 使用yield操作符可以使一个函数变成迭代器。如下一段测试代码：\ndef genTest(n): print 1 print 2 for i in range(3,n+1): yield i print n+1 print n+2 if __name__ == '__main__': for i in genTest(5): print i  输出如下：\n1 2 3 4 5 6 7  可以看出第一次调用genTest()时执行了1,2位置的代码。 之后yield将i返回给caller的i，然后再次调用时继续从genTest上次yield之后的代码执行，直至最后return停止，迭代结束。\nPython解析XML Python解析XML有许多种方法，它们各有特色。\nElementTree ElementTree是python xml解析的一种轻量级实现。 它将XMl文件读取到内存中以一棵树的形式存储。 它速度快且方便使用，但是不能读取不规范的XMl文件，并且会一次将XML文件解析入内存。 因此适合解析一些小型的XML文件。 cElementTree是它的一个C优化过的版本。\n示例代码如下：\ndef readXMLET(filename): try: import xml.etree.cElementTree as ET except ImportError: import xml.etree.ElementTree as ET tree = ET.ElementTree(file=filename) print 'read finish!' root = tree.getroot() for child in root: yield child.tag, child.attrib  BeautifulSoup Parser 刚提到ElementTree不能读取不规范的XML，BeautifulSoup Parser则可以，它试图修复XML中的不规范成分。 但是由于使用了正则表达式，相对的它的效率会低于ElementTree。\n示例代码如下：\ndef readXMLlxml(filename): from lxml.html import soupparser tree = soupparser.parse(filename) root = tree.getroot() for child in root: yield child.tag, child.attrib  SAX 前面两种方法都是将XML一次以一棵树的形式读入内存中。 若是XML文件较大的话这种方式会非常慢且消耗内存。 SAX则是以一种异步的方式处理它遇到的XML标签，而不是将其一次全部解析，因此比较适合体积很大的XML文件。 但是它不会记得之前处理过的标签算是一个缺点。\n你需要继承xml.sax.ContentHandler类，然后在解析的时候将这个类的实例传入即可。\n这个类有如下方法：\n characters(content)方法：调用时机为从行开始，遇到标签之前，存在字符，content的值为这些字符串；从一个标签，遇到下一个标签之前， 存在字符，content的值为这些字符串；从一个标签，遇到行结束符之前，存在字符，content的值为这些字符串。标签可以是开始标签，也可以是结束标签。\n startDocument()方法：文档启动的时候调用。\n endDocument()方法：解析器到达文档结尾时调用。\n startElement(name, attrs)方法：遇到XML开始标签时调用，name是标签的名字，attrs是标签的属性值字典。\n endElement(name)方法：遇到XML结束标签时调用。\n  示例代码如下：\nclass resHandler(xml.sax.ContentHandler): def __init__(self): self.count = 0 def startElement(self, tag, attrib): if tag == 'doc': self.count += 1 if self.count % 1000 == 0: print self.count doc = { TAG:tag, TITLE:attrib[TITLE], ANCHOR:attrib[ANCHOR], H1:attrib[H1], PATH:attrib[PATH], PAGERANK:attrib[PAGERANK] } print doc def readXMLSAX(filename): parser = xml.sax.make_parser() parser.setContentHandler(resHandler()) parser.parse(filename)  "
},{
	"uri": "https://dailydreamer.me/post/2015-06-22-elasticsearch-config-2/",
	"title": "ElasticSearch搜索配置（2）",
	"tags": ["编程", "ElasticSearch"],
	"description": "",
	"content": " 这次再来说说ElasticSearch的其他一些特性。\nBulk 使用Index进行索引是一次索引一条doc，而bulk提供了批量索引的功能，能够显著的减少索引时间。 经过实际测试，对于1个100Mb约20K条doc，向远程服务器单节点发起索引的完成时间对比如下表。\n   chunck_size time/s     200 298.34   500 216.84   1000 169.64   2000 164.71    可以看出chunck_size在一个合适的区间时可以显著减少索引时间，而chunck_size的选取也和一个doc的大小有关。\n这里是官方文档。\nElasticSearch的python API中对bulk进行了封装，有helpers.streaming_bulk和helpers.bulk两个方法，官方文档在这。大致使用方法如下：\nfor success, fail in helpers.streaming_bulk(es, genDoc(filename), index=INDEX, doc_type=DOCTYPE, chunk_size=1000): print 'success: ', success  success, fail = helpers.bulk(es, genDoc(filename), index=INDEX, doc_type=DOCTYPE, chunk_size=1000)  其中geDoc()是一个迭代器。 这两个方法的区别在于bulk调用了streaming_bulk并将信息一起返回。\n拼音搜索 对于中文内容较多的索引，如果能够使用拼音搜索会十分方便。 ElasticSearch有插件elasticsearch-analysis-pinyin可以实现这个功能。 它可以将中文转化为拼音字母，在建立索引的时候就可以在倒排列表中使对应的拼音字母关联到包含中文的Doc上。\n为了将拼音搜索的索引和IK分词的索引结合，需要用到另一个插件elasticsearch-analysis-combo。 它可以将两个Analyzer的结果合并起来得到一个新的Analyzer。\n基本的配置如下。\nindex: analysis: analyzer: ik: alias: [news_analyzer_ik,ik_analyzer] type: org.elasticsearch.index.analysis.IkAnalyzerProvider ik_max_word: type: ik use_smart: false ik_smart: type: ik use_smart: true pinyin: type: custom tokenizer: standard filter: - standard - pinyin_filter - lowercase combo: type: combo sub_analyzers: - ik - pinyin filter: pinyin_filter : type : pinyin first_letter : none padding_char : ''  先使用pinyin插件定义一个pinyin filter， first_letter属性看是否得到拼音首字母缩写，padding_char属性确定首字母缩写和全拼音的连接方式。 然后定义一个custom的pinyin analyzer。tokenizer使用standard，将所有汉字词语分成单个字，filter先通过standard初步过滤，然后使用pinyin filter转成单个字的拼音，最后使用lowercase统一小写。\n效果如下：\n输入命令\ncurl -XGET 'http://localhost:9200/school_search_index/_analyze?analyzer=pinyin\u0026amp;pretty' -d '清华大学'  得到结果\n{ \u0026quot;tokens\u0026quot; : [ { \u0026quot;token\u0026quot; : \u0026quot;qing\u0026quot;, \u0026quot;start_offset\u0026quot; : 0, \u0026quot;end_offset\u0026quot; : 1, \u0026quot;type\u0026quot; : \u0026quot;\u0026lt;IDEOGRAPHIC\u0026gt;\u0026quot;, \u0026quot;position\u0026quot; : 1 }, { \u0026quot;token\u0026quot; : \u0026quot;hua\u0026quot;, \u0026quot;start_offset\u0026quot; : 1, \u0026quot;end_offset\u0026quot; : 2, \u0026quot;type\u0026quot; : \u0026quot;\u0026lt;IDEOGRAPHIC\u0026gt;\u0026quot;, \u0026quot;position\u0026quot; : 2 }, { \u0026quot;token\u0026quot; : \u0026quot;da\u0026quot;, \u0026quot;start_offset\u0026quot; : 2, \u0026quot;end_offset\u0026quot; : 3, \u0026quot;type\u0026quot; : \u0026quot;\u0026lt;IDEOGRAPHIC\u0026gt;\u0026quot;, \u0026quot;position\u0026quot; : 3 }, { \u0026quot;token\u0026quot; : \u0026quot;xue\u0026quot;, \u0026quot;start_offset\u0026quot; : 3, \u0026quot;end_offset\u0026quot; : 4, \u0026quot;type\u0026quot; : \u0026quot;\u0026lt;IDEOGRAPHIC\u0026gt;\u0026quot;, \u0026quot;position\u0026quot; : 4 } ] }  最后使用combo analyzer将两个analyzer合并。\n自动补全 搜索引擎的自动补全有两种类型。 一种是基于你过去或者是其他人的热门的搜索历史进行补全，另一种是基于语言模型进行补全。\n对于第一种根据搜索历史的补全，适用与拥有大量数据的搜索引擎。 在ElasticSearch中可以使用Completion Suggester实现。 由于不适用与用户数据较少的搜索引擎，便不细说，可以参考这篇文章。\n第二种基于语言模型的补全，可以使用类似于拼音搜索的实现方式，在建立索引的时候对一个单词string的所有substring都建立到包含该string的Doc的映射即可。 但是需要注意的是这样会显著增加索引的大小。\n在ElasticSearch中可以使用n-Gram Tokenizer或n-Gram filter实现。 具体可以参考这篇文章。\n"
},{
	"uri": "https://dailydreamer.me/post/2015-06-05-elasticsearch-config-1/",
	"title": "ElasticSearch搜索配置（1）",
	"tags": ["编程", "ElasticSearch"],
	"description": "",
	"content": " 最近在用ElasticSearch做一些搜索，来谈谈其中用到的一些特性。\nElasticSearch是基于Lucene的分布式包装，其中每一个分片或一个副本都是一个Lucene实例。 ElasticSearch实现了很好的扩展性和冗余，自动负载均衡。可以通过Restful API与ElasticSearch集群交互。 我使用的是python API。\n可以参考ElasticSearch权威指南，讲解非常清楚。\n建立索引 建立索引的时候可以使用mapping建立对每个字段建立映射。\nmapping_body = { 'mappings':{ 'tweet':{ \u0026quot;properties\u0026quot;:{ 'text':{'type':'string', 'index':'analyzed', 'analyzer':'ik_smart', 'similarity': 'BM25'} } } } } es.indices.create(index='test-index', body=mapping_body)  上面为\u0026rsquo;test-index\u0026rsquo;的索引中\u0026rsquo;tweet\u0026rsquo;的type中\u0026rsquo;text\u0026rsquo;字段建立映射。\n\u0026lsquo;index\u0026rsquo;设置为analyzed说明要先通过分析器，\u0026rsquo;analyzer\u0026rsquo;设置分析器为ik分词的智能粒度切分，默认为standard，不适合中文分词;\u0026lsquo;similarity\u0026rsquo;设置了相似度算法为BM25，默认为向量空间算法。\n具体可以看文档。\n查询 查询可以通过ID来检索，但是作为一个搜索引擎，ElasticSearch提供了一种基于JSON的DSL查询格式。\nsearch_body = { \u0026quot;query\u0026quot;: { \u0026quot;multi_match\u0026quot;: { \u0026quot;query\u0026quot;: \u0026quot;Hello世界\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;cross_fields\u0026quot;, \u0026quot;operator\u0026quot;: \u0026quot;or\u0026quot;, \u0026quot;fields\u0026quot;: [ \u0026quot;author\u0026quot;, \u0026quot;text^2\u0026quot; ] } }, 'highlight':{ 'fields':{ 'author':{}, 'text':{} } } } res = es.search(index='test-index', doc_type='tweet', body=search_body)  Query 上面的示例中使用了multi match query来进行多字段查询，multi match query对fields中的每个field进行query查询。\n\u0026lsquo;operator\u0026rsquo;定义了对查询结果进行的操作，\u0026rsquo;or\u0026rsquo;代表取并集。\nfields中的^代表对该字段进行boost，之后的值为浮点数，小于1表示减轻权重，否则加大权重。\n\u0026lsquo;type\u0026rsquo;中的类型和适用场景见下表\n   Type Explain     best_fields (default) Finds documents which match any field, but uses the _score from the best field. See best_fields.   most_fields Finds documents which match any field and combines the _score from each field. See most_fields.   cross_fields Treats fields with the same analyzer as though they were one big field. Looks for each word in any field. See cross_fields.   phrase Runs a match_phrase query on each field and combines the _score from each field. See phrase and phrase_prefix.   phrase_prefix Runs a match_phrase_prefix query on each field and combines the _score from each field. See phrase and phrase_prefix.    cross_fields是将所有字段放在一起搜索，跟对_all进行query相比它可以附加权重，但是效率略微低一点。\n更加详细的type的使用情景可以看权威指南的Know Your Data一节。\nFunction Score query和script 如果需要吧离线算好的pagerank和在线查询的得分结合起来给结果排序，可以使用强大的Function Score query和script来做到这一点。\n\u0026quot;query\u0026quot;:{ \u0026quot;function_score\u0026quot;: { \u0026quot;boost_mode\u0026quot;: \u0026quot;replace\u0026quot;, \u0026quot;query\u0026quot;: { \u0026quot;multi_match\u0026quot;: { \u0026quot;query\u0026quot;:query, \u0026quot;type\u0026quot;:\u0026quot;cross_fields\u0026quot;, \u0026quot;operator\u0026quot;:\u0026quot;or\u0026quot;, \u0026quot;fields\u0026quot;:SEACHFIELDS } }, \u0026quot;script_score\u0026quot;: { \u0026quot;lang\u0026quot;:\u0026quot;groovy\u0026quot;, \u0026quot;params\u0026quot;: { \u0026quot;pagerankField\u0026quot;: PAGERANK, \u0026quot;pagerankW\u0026quot;: PAGERANKW, \u0026quot;scoreW\u0026quot;: 1 - PAGERANKW }, \u0026quot;script_file\u0026quot;: \u0026quot;school-search\u0026quot; } } }  使用function_score将原query包裹起来，在script_score中，lang设置脚本语言，默认为groovy;params设置脚本参数，script_file指定脚本文件，脚本文件保存在./config/scripts/下，不用写出后缀名，config/scripts/group1/group2/test.py应该命名为group1_group2_test。\n脚本内容类似下面\n_score * scoreW + doc[pagerankField].value * pagerankW  其中_score是query得分，doc[field_name]可以获得当前doc的field，也可在其中使用parms中指定的参数。\n还有一种使用脚本的方法是将其索引在一个特殊文件.scripts中，但是由于这个功能曾经爆出漏洞，而且性能不如上面的方法，现在已经默认关闭，在此不再讨论。\nHighlight 使用highlight可以在返回结果的\u0026rsquo;highlight\u0026rsquo;字段中对匹配词进行高亮，\u0026rsquo;fields\u0026rsquo;设置要高亮的field，还可以对高亮格式进行设置，默认为。详细可以看这里。\nFilter filter更像是数据库中的一些操作，不会返回_score值，只有满足条件才会被返回，但是相比query效率更高。详细可以看这里。\n有了这些基本能够满足简单的搜索需要了。\n找到了一个翻译了一部分权威指南的Blog，记录在这里。\n"
},{
	"uri": "https://dailydreamer.me/post/2015-06-04-a-pragmatic-programmer/",
	"title": "程序员修炼之道",
	"tags": ["读书笔记", "编程"],
	"description": "",
	"content": " 这本书出版有些年头了，虽然其中的例子有些老旧，但是有些思想和哲学永远不会过时。\n注重实效的哲学 负责，提供各种选择，不找蹩脚的借口。\n避免软件腐烂，破窗效应，不要容忍破窗户。\n启动杂役，做变化的催化剂。\n不要被温水煮青蛙，留意大图景。\n让用户参与权衡，使质量成为需求问题。\n像管理金融资产一样管理知识资产。定期为你的知识资产投资。\n不要搁置问题。\n批判的分析你读到的和听到的。\n注重交流，想清楚你要说什么，了解听众。\n注重实效的途径 重复的危害 系统中的每一项知识都必须具有单一、无歧义、权威的表示。Don\u0026rsquo;t Repeat Yourself！这不是你是否能记住的问题，而是何时忘记的问题。\n强加的重复：\n客户端服务器端不同语言：可以根据元数据在Build时生成不同语言的类定义及结构。\n根据需求文档自动生成测试。\n无意的重复：\n需要缓存时可能会破坏DRY原则，但是应该在类内部解决，不要将其暴露给外界。\n正交性 消除无关事物之间的影响。\n可撤销性 不存在最终决策，采用灵活的架构。\n曳光弹 用曳光弹找到目标，给出可展示的项目骨架，它可以即时的反馈。\n原型与便笺 为了学习而制作原型。原型甚至可以不用编码，他需要确定各个组件的责任和是否解耦。\n基本工具 用纯文本保存知识。它不会过时，更易测试。\n要修正问题，而不是发出指责。\n再现bug，使数据可视化。\n向别人讲述你的代码要做什么时可能会帮助你理清思路。\n不要假定，要证明。\n注重实效的偏执 你不可能写出完美的软件。\nDBC 按合约设计 前条件，后条件，类不变项。\n死程序不说谎 早崩溃，要崩溃不要破坏。\n断言式编程 如果他不可能发生，用断言确保。\n弯曲，或折断 使模块之间的耦合减至最小。\n要配置，不要集成。\n将抽象放进代码，将细节放进元数据。\n总是为并发进行设计。\n使模型与视图分离。\n当你编码时 不要靠巧合编程。\n为你的假定建立文档。\n早重构，常重构。这是一种痛苦管理。经常进行短小的重构之后测试。\n测试驱动的设计。测试你的软件，否则你的用户就得测试。\n与用户一同工作，以像用户一样思考。\n抽象比细节获得更长久。\n不要在盒子外面思考，要找到盒子，即真正的约束。亚历山大大帝用剑劈开了弗里吉亚国王戈尔系的号称解不开的结。\n有些事情去做胜于描述，比如试着描述一下你系鞋带的过程。不要一开始编写太过详尽的规范。它和编码总是交替进行。\n不要做形式方法的奴隶，有时原型展示比UML图更有说服力。昂贵的工具不一定能制作出更好的设计。\n注重实效的项目 不要使用手工流程。\n早测试，常测试，自动测试。\n温和的超出用户的期望。与用户交流期望。\n在你的作品上签名。这是责任和荣耀的表现。\n"
},{
	"uri": "https://dailydreamer.me/post/2015-06-02-config-elasticsearch-on-aws/",
	"title": "在AWS上配置ElasticSearch",
	"tags": ["编程", "ElasticSearch"],
	"description": "",
	"content": " 最近在AWS EC2上部署了ElasticSearch，感觉AWS的文档详细但稍显凌乱，在这里总结一下步骤。\n首先注册AWS。注意你需要一张支持外币支付的信用卡。\n然后创建IAM用户，并配置其权限和密钥对。 可按照文档中的步骤来。 注意为了使elasticsearch节点启动后能够自动发现别的节点，你可能需要在这一步为该用户而外设置read-only权限。\n之后有两种方案，可以直接部署在EC2上，价格便宜量又足。 也可以部署在EMR上，获得Haddop的集群管理能力，方便扩展以及将来部署其它基于Haddop的程序。但是注意使用EMR除了支付EMR的计费还要支付其使用的EC2及S3等的计费。\n部署在EC2上 进入EC2控制面板启动实例。 如果你希望数据在EC2实例关闭后不丢失需要为其配置挂载EBS卷并将其存储至EBS中，详细见文档。\n注意EBS卷最好在home/ec2-user/下新建目录挂载，上次我挂载在home/ec2-user/下结果不知道.ssh是存在那里的，然后就连接不上了。。。 挂载完EBS卷后需要更改其权限使得普通用户可以读写文件。 sudo chmod 777 ./ -R\n之后为其配置EIP来避免每次重启实例后IP地址改变。 EIP是一个固定的共有IP，将其和一个EC2实例的私有IP绑定即可。 这样也方便切换实例而IP不变。\n最后即可ssh连接到EC2上然后安装ElasticSearch了。\n安装好ElasticSearch之后还需安装elasticsearch-cloud-aws插件并配置才能实现自动Discovery。 大致的配置如\n# AWS discovery cloud.aws.access_key: KEY cloud.aws.secret_key: KEY plugin.mandatory: cloud-aws discovery.type: ec2 discovery.zen.ping.multicast.enabled: false discovery.ec2.groups: \u0026quot;elasticsearch\u0026quot; discovery.ec2.availability_zones: \u0026quot;ap-northeast-1a\u0026quot; cloud.aws.region: \u0026quot;ap-northeast-1\u0026quot; discovery.ec2.host_type: \u0026quot;public_ip\u0026quot; network.publish_host: [PUBLIC_IP] discovery.ec2.ping_timeout: \u0026quot;30s\u0026quot;  discovery.ec2.groups是你的EC2集群所在的安全组，注意用这种方式的设置会将必须该安全组中所有节点都启动ElasticSearch服务才行，否则会一直等待。 如果不想这样可以使用Tag设置。\ndiscovery.ec2.availability_zones一定要写对，否则节点会无法互相发现，不知道可以看EC2控制面版中有写。\nnetwork.publish_host是该节点的公网IP，可使用绑定的弹性IP。\n更加详细的设置可以看这里。\n有关部署的更加详细的步骤可以参考这里。\n注意如果弹性IP更换了绑定的实例之后要ssh之前需要将原来保存在本地的host_key删除，使用命令ssh-keygen -R hostname,否则会报Host key verification failed。\n部署在EMR上 安装AWS CLI。 可按照文档安装并配置。\n然后直接使用Amazon EMR的bootstrp action脚本即可。 这个仓库中还有其它基于Hadooop的软件的启动脚本，如spark，cascading等。\n输入命令(相关参数可自行配置)\naws emr create-cluster \\ --ec2-attributes KeyName=\u0026quot;\u0026lt;YOUR_EC2_KEYNAME\u0026gt;\u0026quot; \\ --log-uri=\u0026quot;\u0026lt;YOUR_LOGGING_BUCKET\u0026gt;\u0026quot; \\ --bootstrap-action \\ Name=\u0026quot;Install ElasticSearch\u0026quot;,Path=\u0026quot;s3://support.elasticmapreduce/bootstrap-actions/other/elasticsearch_install.rb\u0026quot; \\ Name=\u0026quot;Installkibanaginx\u0026quot;,Path=\u0026quot;s3://support.elasticmapreduce/bootstrap-actions/other/kibananginx_install.rb\u0026quot; \\ Name=\u0026quot;Installlogstash\u0026quot;,Path=\u0026quot;s3://support.elasticmapreduce/bootstrap-actions/other/logstash_install.rb\u0026quot; \\ --ami-version=3.5.0 \\ --instance-count=3 \\ --instance-type=m1.medium \\ --name=\u0026quot;TestElasticSearch\u0026quot;  即可启动一个3节点的elasticsearch集群，并安装kibana和logstash。\n至此，ElasticSearch集群便部署完成了。Enjoy your search~\n"
}]