<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>编程 on dailydreamer</title>
    <link>https://dailydreamer.me/tags/%E7%BC%96%E7%A8%8B/index.xml</link>
    <description>Recent content in 编程 on dailydreamer</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <atom:link href="https://dailydreamer.me/tags/%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>从函数式语言想到的</title>
      <link>https://dailydreamer.me/post/2016-06-09-inspired-by-functional-programing-language/</link>
      <pubDate>Thu, 09 Jun 2016 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/post/2016-06-09-inspired-by-functional-programing-language/</guid>
      <description>

&lt;p&gt;最近看了一本书&lt;a href=&#34;https://pragprog.com/book/btlang/seven-languages-in-seven-weeks&#34;&gt;Seven Languages in Seven Weeks&lt;/a&gt;。
原来一直都在面向对象编程，对函数式语言了解并不多，看完这本书之后还是很受启发，接触了许多不同语言的新的思想。&lt;/p&gt;

&lt;h2 id=&#34;各种编程范式&#34;&gt;各种编程范式&lt;/h2&gt;

&lt;h3 id=&#34;imperative-programming&#34;&gt;imperative programming&lt;/h3&gt;

&lt;p&gt;古老的编程范式，以冯诺以曼结构的机器思考的方式编程，如C语言。&lt;/p&gt;

&lt;h3 id=&#34;object-oriented-programming&#34;&gt;object oriented programming&lt;/h3&gt;

&lt;p&gt;现在正当年的主力编程范式，如Java、C#、ruby、python，以及深度融合了函数式思想但本质还是OOP的scala。&lt;/p&gt;

&lt;p&gt;它的分支Prototype-based programming，如JavaScript，是一种十分灵活的编程方式。
没有Class定义，所有的Object都以另一个Object为prototype，可以很灵活的改变原型链上的Object的数据和方法。&lt;/p&gt;

&lt;h3 id=&#34;logic-programming&#34;&gt;logic programming&lt;/h3&gt;

&lt;p&gt;面向推理逻辑的特定编程范式，是一种高等级的抽象，如prolog，声明定义和推导即可得出特定问题的答案。&lt;/p&gt;

&lt;h3 id=&#34;functional-programming&#34;&gt;functional programming&lt;/h3&gt;

&lt;p&gt;被认为是下一代的编程范式。
函数式编程范式基于lambda calculus的思想，很早就在大名鼎鼎Lisp中出现。
其核心思想是认为一切程序都可以由纯函数组成，纯函数没有副作用，输入一样则输出必然一样；
所有数据结构都是immutable的，其值不能被改变。&lt;/p&gt;

&lt;p&gt;早年由于我们的计算机架构是冯诺以曼结构，其基本操作都是基于副作用的，因此这种函数式编程带来的性能上的极大损失使其没有像命令式编程一样成为主流语言。
现在随着计算机性能的提升以及相关理论和实现的完善，函数式编程的思想带来的好处逐渐体现，并且也积极的影响着其它现在的主流语言。
同时涌现了一批为了兼容现有平台而作出一定妥协的”过渡性语言”，如Scala（Better Java）、Clojure（JVM上的Lisp）、F#（.Net上的OCaml）。&lt;/p&gt;

&lt;h2 id=&#34;函数式语言的积极影响&#34;&gt;函数式语言的积极影响&lt;/h2&gt;

&lt;h3 id=&#34;基于immutable思想的数据结构&#34;&gt;基于immutable思想的数据结构&lt;/h3&gt;

&lt;p&gt;immutable带来的好处是程序的结果更加的可以预测，变量不会在你看不见的地方被偷偷改变。
而且在多核的并行架构下Immutable能够避免复杂的状态和逻辑维护，使程序更加高效简单。&lt;/p&gt;

&lt;p&gt;过去Lisp中主要的immutable数据结构是List,在某些情况下这种数据结构的性能非常糟糕（如查找是O(n)）。
而现在一些精巧复杂的树状的数据结构可以兼顾immutable和性能（以一定的存储空间为代价），如&lt;a href=&#34;https://infoscience.epfl.ch/record/64398/files/idealhashtrees.pdf&#34;&gt;Ideal Hash Trees&lt;/a&gt;中的Hash array mapped trie(HAMT)。
&lt;a href=&#34;http://hypirion.com/musings/understanding-persistent-vector-pt-1&#34;&gt;这篇文章&lt;/a&gt;详细讲解了Clojure中的Persistent Vectors（虽然叫Vector但只是接口一样，实际这货是个树）的实现原理。
它基于HAMT，能够在保持immutable维护过去状态以供回滚的同时达到增加、更新、查找都为O(1)的性能。
知乎上的&lt;a href=&#34;http://www.zhihu.com/question/35244627&#34;&gt;这个讨论&lt;/a&gt;介绍了一些其它的相关数据结构。&lt;/p&gt;

&lt;h3 id=&#34;基于immutable的系统&#34;&gt;基于immutable的系统&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://nixos.org/&#34;&gt;Nix OS&lt;/a&gt;是一种使用Nix packager manager的纯函数式思想的系统。
Nix packager manager也可以在Linux和Mac OS X上使用。
它将每一个软件包都独立开来，升级软件的时候不会影响原来已经安装好的其它版本的该软件，使得软件可以轻松回滚，并且不会出现由于版本导致的各种问题，是ruby的RVM，node.js的NVM，python的virtualenv等等软件所解决问题的终极解决方案。&lt;/p&gt;

&lt;h3 id=&#34;类型&#34;&gt;类型&lt;/h3&gt;

&lt;p&gt;Haskell拥有强大的类型系统。
static type是指其编译时进行类型检查，strong type是指其类型检查要求类型严格匹配。
配合type inference，Haskell的类型系统做到了你不需要时感受不到，需要清晰接口时可以显示声明。
它永远在保障着程序的正确性，不会产生JavaScript中一些被人广泛诟病的错误（&lt;a href=&#34;https://www.destroyallsoftware.com/talks/wat&#34;&gt;这个视频&lt;/a&gt;我笑了好久。。。）。
Scala中也有type inference，但是由于JVM的限制功能很有限。&lt;/p&gt;

&lt;p&gt;Haskell中的type class可以优雅的实现generics和polymorphism，并且可以避免很多OOP中因为不能把函数作为一等公民传递（高阶函数）而造成的臃肿的设计模式。
Julia中multiple dispatch更进一步，根据每个参数的类型不同调用不同的函数实现，更符合直觉，且避免了OOP中dynamic dispatch的动态查找带来的性能损失。&lt;/p&gt;

&lt;h3 id=&#34;并发&#34;&gt;并发&lt;/h3&gt;

&lt;p&gt;OOP中对于并发的处理通常是基于thread以及共享内存和互斥锁，这个模型被实践证明即使是有经验的程序员也很难驾驭。
而许多函数式语言提出了更好的解决方案。&lt;/p&gt;

&lt;p&gt;erlang是为了稳定的企业级基础服务而开发的语言。
erlang虚拟机使得新建进程更加轻量，进程间通讯更加方便。
结合immutable特性以及actor进程池模型和消息传递来解决并发问题。
erlang虚拟机还有一个厉害的特性是能够在语言内轻易管理进程的生命周期，这催生了独特的let it crash哲学，以及不用停止程序即可修改代码等等的神奇功能，使得erlang程序可以运行多年而不用重启。&lt;/p&gt;

&lt;p&gt;scala中也使用actor作为并发模型。
clojure中借鉴了关系型数据库的transactional特性，使用software transactional memory管理并发。&lt;/p&gt;

&lt;p&gt;这些模型都被实践证明更加容易产生可靠的代码且更容易理解。&lt;/p&gt;

&lt;h3 id=&#34;pattern-matching&#34;&gt;Pattern matching&lt;/h3&gt;

&lt;p&gt;不同于传统OOP对象相等比较的是引用相等，如Java中String类型的&lt;code&gt;==&lt;/code&gt;和&lt;code&gt;equals()&lt;/code&gt;的令人迷惑的区别，Pattern matching是深度比较两个对象，更加符合直觉，并且配合immutable也可以有很好的性能。
当然Pattern Matching更加灵活，带来了匹配类型，destructing等等实用的功能。&lt;/p&gt;

&lt;h3 id=&#34;meta-programming&#34;&gt;meta programming&lt;/h3&gt;

&lt;p&gt;Lisp中程序即数据，整个程序就是用List数据结构表达的，使得其macro远远强大于C的字符串替换，可以实现很多优雅的domain specific language(DSL)。
后来很多语言都将macro和meta programming作为自己的重要特性，即使是拥抱了OOP的ruby和scala。&lt;/p&gt;

&lt;h3 id=&#34;其它&#34;&gt;其它&lt;/h3&gt;

&lt;p&gt;如Currying，Functor，Applicative，Monad等等新的概念和抽象，使用Maybe Monad杜绝Null这一Java程序员永远的痛等等。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;函数式编程为我们带来了更优雅简洁易懂的程序，以及许多优秀的思想。
虽然今天的主流语言仍然是OOP，但是我们可以靠自己慢慢推动新一代编程范式的发展，找到最佳的结合点。&lt;/p&gt;

&lt;p&gt;需要注意的是不应该盲目推崇函数式编程的思想。
编程语言里还有另一种实用派，学术派眼中的“另类”，从实际出发得出的迥然不同的语言，如C和go。
不同的思路有着不同的权衡取舍，取其精华去其糟粕，结合自己的使用场景选择，合适的才是最好的。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>WebRTC简介</title>
      <link>https://dailydreamer.me/post/2016-05-25-webrtc-introduction/</link>
      <pubDate>Wed, 25 May 2016 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/post/2016-05-25-webrtc-introduction/</guid>
      <description>

&lt;h2 id=&#34;webrtc-http-www-html5rocks-com-en-tutorials-webrtc-basics-简介&#34;&gt;&lt;a href=&#34;http://www.html5rocks.com/en/tutorials/webrtc/basics/&#34;&gt;WebRTC&lt;/a&gt;简介&lt;/h2&gt;

&lt;p&gt;WebRTC是一种在浏览器中无需任何插件的点对点(P2P)实时视频、音频、数据交流协议，其中RTC是实时沟通(Real Time Communication)的缩写。
过去，实时沟通昂贵且实现复杂，需要专用的视频和音频设备及技术，使得将其集成进已有服务昂贵且费时。
后来，Google开源了Gmail和Hangouts中使用的RTC技术，并且参与W3C相关规范的制定。
2011年，WebRTC第一个版本被实现。
现在WebRTC技术已经被WhatsApp, Facebook Messenger等应用广泛使用。&lt;/p&gt;

&lt;p&gt;WebRTC主要实现了3个API，&lt;code&gt;getUserMedia&lt;/code&gt;、&lt;code&gt;RTCPeerConnection&lt;/code&gt;和&lt;code&gt;RTCDataChannel&lt;/code&gt;。
其中&lt;code&gt;getUserMedia&lt;/code&gt;定义了来获取设备上的视频(包括摄像头输入和屏幕输入等)、音频流的接口。&lt;code&gt;RTCPeerConnection&lt;/code&gt;定义了用于处理两个客户端之间的流数据的接口。&lt;code&gt;RTCDataChannel&lt;/code&gt;定义了用于处理两个客户端之间任意数据收发的接口。&lt;/p&gt;

&lt;h2 id=&#34;使用webrtc过程&#34;&gt;使用WebRTC过程&lt;/h2&gt;

&lt;p&gt;使用WebRTC时需要如下步骤：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;使用getUserMedia获取MediaStream流数据，此时可以用Constraints对MediaStream的帧率、宽、高等进行设置。&lt;/li&gt;
&lt;li&gt;使用RTCPeerConnection初始化客户端session，将MediaStream附加到session上。&lt;/li&gt;
&lt;li&gt;获取网络信息(如IP地址、端口等)，与其他客户端进行Signaling(信令交换)。
该过程使用&lt;a href=&#34;https://en.wikipedia.org/wiki/Session_Description_Protocol&#34;&gt;SDP（Session Description Protocol）协议&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;Signaling交换流媒体数据信息(如编码、分辨率等)。&lt;/li&gt;
&lt;li&gt;Signaling过程完成，直接点对点交换流媒体数据MediaStream。&lt;/li&gt;
&lt;li&gt;(可选)建立RTCDataChannel进行数据交换。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;实际应用中，会遇到客户端处于防火墙或NAT之后等复杂情况，这时需要用到&lt;a href=&#34;http://en.wikipedia.org/wiki/STUN&#34;&gt;STUN协议&lt;/a&gt;或&lt;a href=&#34;https://en.wikipedia.org/wiki/Traversal_Using_Relays_around_NAT&#34;&gt;TURN协议&lt;/a&gt;等来实现防火墙和NAT穿透，获取真实的网络信息。&lt;/p&gt;

&lt;p&gt;由于WebRTC在建立session之后流媒体数据是点对点传输，这样虽然很快，但是如果遇到大量客户端的视频会议等场景，客户端之间需要两两连接，对于客户端带宽要求很高。
这时就需要&lt;a href=&#34;https://en.wikipedia.org/wiki/Multipoint_control_unit&#34;&gt;MCU(Multipoint Control Unit)&lt;/a&gt;来改变网络拓扑，节省带宽提高性能。&lt;/p&gt;

&lt;p&gt;WebRTC在Signaling过程中需要使用其他双向数据协议进行信息交换，如WebSocket或XMPP等。&lt;/p&gt;

&lt;p&gt;由于WebRTC标准实现还未最终完全确定，各个浏览器都需开启实验性功能才能使用，可以考虑Chrome插件或者使用Electron封装成桌面程序的形式提供更好的用户体验。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>DOM和DOM Event</title>
      <link>https://dailydreamer.me/post/2016-04-25-dom-and-dom-event/</link>
      <pubDate>Mon, 25 Apr 2016 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/post/2016-04-25-dom-and-dom-event/</guid>
      <description>

&lt;h2 id=&#34;dom和html-javascript-css的关系&#34;&gt;DOM和HTML，JavaScript，CSS的关系&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction&#34;&gt;Document Object Model(DOM)&lt;/a&gt;是W3C制定的一种语言无关的面向对象的文档模型，规定了一组可编程的interface需要实现的属性和方法。
HTML和XML文档实现了DOM，因此拥有面向对象的特性，其结构、样式、内容等可以被其他语言的DOM实现操纵。
DOM Level 4是2015年的最新一版标准。&lt;/p&gt;

&lt;p&gt;HTML中&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;元素中嵌入的JavaScript就是DOM的一种实现，如下所示：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var paragraphs = document.getElementsByTagName(&amp;quot;P&amp;quot;);
// paragraphs[0] is the first &amp;lt;p&amp;gt; element
// paragraphs[1] is the second &amp;lt;p&amp;gt; element, etc.
alert(paragraphs[0].nodeName);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;document&lt;/code&gt;对象，&lt;code&gt;getElementsByTagName&lt;/code&gt;方法，&lt;code&gt;alert&lt;/code&gt;方法，&lt;code&gt;nodeName&lt;/code&gt;属性均是DOM标准规定的。&lt;/p&gt;

&lt;p&gt;你也可以用其它语言操作DOM，如下的Python示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;# Python DOM example
import xml.dom.minidom as m
doc = m.parse(&amp;quot;test.xml&amp;quot;);
doc.nodeName # DOM property of document object;
p_list = doc.getElementsByTagName(&amp;quot;para&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HTML是一种文档标记语言，HTML元素除了实现DOM的interface之外，还实现了HTML标准中规定的一些interface。如下示例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;var table = document.getElementById(&amp;quot;table&amp;quot;);
var tableAttrs = table.attributes; // Node/Element interface
for (var i = 0; i &amp;lt; tableAttrs.length; i++) {
  // HTMLTableElement interface: border attribute
  if(tableAttrs[i].nodeName.toLowerCase() == &amp;quot;border&amp;quot;)
    table.border = &amp;quot;1&amp;quot;;
}
// HTMLTableElement interface: summary attribute
table.summary = &amp;quot;note: increased border&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;attributes&lt;/code&gt;属性是DOM标准，&lt;code&gt;border&lt;/code&gt;和&lt;code&gt;summary&lt;/code&gt;属性是HTML标准。&lt;/p&gt;

&lt;p&gt;其它XML的方言如SVG等也有实现DOM之外的标准。&lt;/p&gt;

&lt;p&gt;CSS是一种为DOM文档标记样式的语言，而DOM Element种的style属性被解释为行内样式表。&lt;/p&gt;

&lt;h2 id=&#34;dom-event&#34;&gt;DOM Event&lt;/h2&gt;

&lt;p&gt;DOM Level 2中规定了基本的&lt;a href=&#34;https://www.w3.org/TR/DOM-Level-2-Events/events.html&#34;&gt;DOM Event Model&lt;/a&gt;，包括事件的处理流程以及注册方法等等。
这里主要讲一下事件处理流程，感觉和WPF的事件机制很相似。&lt;/p&gt;

&lt;h3 id=&#34;基本流程&#34;&gt;基本流程&lt;/h3&gt;

&lt;p&gt;在DOM implementation中触发事件后，触发事件的元素EventTarget被指定给Event对象的target属性。
如果该事件没有使用事件捕获和事件冒泡，那么所有的EventListener被执行后事件处理结束。
如果使用了事件捕获或事件冒泡，那么事件传播过程如后文所示，依次执行过程中所有元素上注册的该事件的EventListener。
执行过程是同步的，且一个EventListener内的异常不会影响后续EventListener的执行。&lt;/p&gt;

&lt;h3 id=&#34;事件捕获-event-capture&#34;&gt;事件捕获(Event capture)&lt;/h3&gt;

&lt;p&gt;事件捕获阶段，事件从DOM树的顶端元素，通常是Document，沿着EventTarget的祖先元素向EventTarget传播。
设置addEventListener方法的useCapture属性为true可以使该EventListener在事件捕获阶段截获由其后代元素产生的相应事件，同时该EventListener在事件冒泡阶段不会再被触发。&lt;/p&gt;

&lt;p&gt;注意和WPF等基于delegation的模型不同的是，截获的是后代元素的相应事件，这意味者如果EventTarget上的设置useCapture的EventListener不会被触发，因为自己不是自己的后代；
并且指定的不是一个EventTarget，而是一种特定的事件类型，如果事件类型不同不会被触发。&lt;/p&gt;

&lt;h3 id=&#34;事件冒泡-event-bubbling&#34;&gt;事件冒泡(Event bubbling)&lt;/h3&gt;

&lt;p&gt;事件冒泡阶段，一开始和没有使用冒泡的事件一样，所有EventTarget上的EventListener都被执行。
然后从EventTarget沿着DOM树，向其祖先元素传播，直到DOM树顶端，过程和事件捕获相反。
设置了useCapture属性的EventListener不会在这一阶段被触发。&lt;/p&gt;

&lt;p&gt;事件传播的链条在事件被触发时就已经确定，传播过程中DOM树的改变不影响传播过程。&lt;/p&gt;

&lt;h3 id=&#34;stoppropagation&#34;&gt;stopPropagation&lt;/h3&gt;

&lt;p&gt;在事件传播的过程中，如果一个EventListener调用了Event对象的stopPropagation方法，那么事件会停止传播，链条上后续元素的EventListener不会被触发。&lt;/p&gt;

&lt;h3 id=&#34;preventdefault&#34;&gt;preventDefault&lt;/h3&gt;

&lt;p&gt;一些事件被指定为cancelable。这些事件的DOM implementation通常都会有一些默认的事件处理方法。在这些事件上调用preventDefault方法可以阻止这些事件处理方法的执行。&lt;/p&gt;

&lt;p&gt;如下例子展示了用preventDefault阻止非小写字母的输入。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
&amp;lt;title&amp;gt;preventDefault example&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;p&amp;gt;请输入一些字母,只允许小写字母.&amp;lt;/p&amp;gt;
&amp;lt;form&amp;gt;
&amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;my-textbox&amp;quot;/&amp;gt;
&amp;lt;/form&amp;gt;
&amp;lt;script type=&amp;quot;text/javascript&amp;quot;&amp;gt;
function checkName(evt) {
var charCode = evt.charCode;
  if (charCode != 0) {
    if (charCode &amp;lt; 97 || charCode &amp;gt; 122) {
      evt.preventDefault();
      alert(&amp;quot;只能输入小写字母.&amp;quot; + &amp;quot;\n&amp;quot;
            + &amp;quot;charCode: &amp;quot; + charCode + &amp;quot;\n&amp;quot;
      );
    }
  }
}
document.getElementById(&#39;my-textbox&#39;).addEventListener(
    &#39;keypress&#39;, checkName, false
 );
&amp;lt;/script&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;常用的mouseevent&#34;&gt;常用的MouseEvent&lt;/h3&gt;

&lt;p&gt;有click，mousedown，mouseup，mouseover，mousemove，mouseout。&lt;/p&gt;

&lt;p&gt;click是在同一屏幕位置的mousedown和mouseup先后依次触发后被触发。&lt;/p&gt;

&lt;p&gt;MouseEvent都会冒泡，并且除mousemove外都Cancelable。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CSS Cheat Sheet</title>
      <link>https://dailydreamer.me/post/2016-04-14-css-cheat-sheet/</link>
      <pubDate>Thu, 14 Apr 2016 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/post/2016-04-14-css-cheat-sheet/</guid>
      <description>

&lt;h2 id=&#34;html&#34;&gt;HTML&lt;/h2&gt;

&lt;p&gt;block element块级元素，撑满一行&lt;/p&gt;

&lt;p&gt;inline element行内元素，宽度包围内容&lt;/p&gt;

&lt;h2 id=&#34;css原理&#34;&gt;CSS原理&lt;/h2&gt;

&lt;h3 id=&#34;选择符&#34;&gt;选择符&lt;/h3&gt;

&lt;p&gt;a, b {} 同时选中a和b&lt;/p&gt;

&lt;p&gt;a b {} a是b的祖先元素时选中b&lt;/p&gt;

&lt;p&gt;a &amp;gt; b {} a是b的父元素时选中b&lt;/p&gt;

&lt;p&gt;a + b {} a紧邻b时选中b&lt;/p&gt;

&lt;p&gt;a ~ b {} a和b是同胞时选中b&lt;/p&gt;

&lt;p&gt;* {} 全部选中&lt;/p&gt;

&lt;p&gt;.a {} 选中a类&lt;/p&gt;

&lt;p&gt;#a {} 选中id为a&lt;/p&gt;

&lt;p&gt;a.b {} 选中同时为a标签和b类&lt;/p&gt;

&lt;p&gt;.a.b {} 选中同时为a类和b类&lt;/p&gt;

&lt;p&gt;a[b] {} 选中a标签中带有b属性的&lt;/p&gt;

&lt;p&gt;a[b=c] {} 选中a标签中b属性值为c的&lt;/p&gt;

&lt;h4 id=&#34;伪类&#34;&gt;伪类&lt;/h4&gt;

&lt;p&gt;a标签 a:link a:visited a:hover a:active&lt;/p&gt;

&lt;p&gt;a:focus a:target&lt;/p&gt;

&lt;p&gt;一组同胞元素中的第几个 a:first-child a:last-child a:nth-child(n) a:nth-child(odd) a:nth-child(even)&lt;/p&gt;

&lt;h4 id=&#34;伪元素&#34;&gt;伪元素&lt;/h4&gt;

&lt;p&gt;a::first-letter a::first-line&lt;/p&gt;

&lt;p&gt;a::before a::after&lt;/p&gt;

&lt;p&gt;搜索引擎不会索引伪元素&lt;/p&gt;

&lt;h4 id=&#34;继承&#34;&gt;继承&lt;/h4&gt;

&lt;p&gt;字体颜色等相关属性会继承，位置等相关属性不会继承&lt;/p&gt;

&lt;h3 id=&#34;浏览器层叠样式表顺序&#34;&gt;浏览器层叠样式表顺序&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;浏览器默认&lt;/li&gt;
&lt;li&gt;用户样式表&lt;/li&gt;
&lt;li&gt;作者链接样式表（按链接先后顺序）&lt;/li&gt;
&lt;li&gt;作者嵌入样式表&lt;/li&gt;
&lt;li&gt;作者行内样式表&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;特指度：包含多少标签、类名、ID等（I-C-E三位数），特指度高的优先级高&lt;/p&gt;

&lt;p&gt;特指度相同时顺序靠后的优先级高&lt;/p&gt;

&lt;h3 id=&#34;css属性&#34;&gt;CSS属性&lt;/h3&gt;

&lt;p&gt;文本值&lt;/p&gt;

&lt;p&gt;数字值&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;px 像素&lt;/li&gt;
&lt;li&gt;em 字体中M的宽度&lt;/li&gt;
&lt;li&gt;ex 字体中x的高度&lt;/li&gt;
&lt;li&gt;百分比&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;颜色值（颜色名，RGB，HSL，16进制）&lt;/p&gt;

&lt;h2 id=&#34;定位元素&#34;&gt;定位元素&lt;/h2&gt;

&lt;p&gt;垂直外边距叠加：垂直方向相邻两个box取margin较大的作为外边距&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-css&#34;&gt;p {
  font-size: 1em;
  margin: .75em 30px;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上排版文字最好垂直相对外边距，水平绝对外边距&lt;/p&gt;

&lt;p&gt;给设定了宽度\高度的盒子加边框、内边距、外边距会使盒子更宽\更高。CSS3的box-sizing属性可以消除这一特点。&lt;/p&gt;

&lt;h3 id=&#34;position&#34;&gt;position&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;static：普通文档流&lt;/li&gt;
&lt;li&gt;relative: 仍然在文档流中，相对原来的box位置变化，原来box占据的位置不变&lt;/li&gt;
&lt;li&gt;absolute：从文档流中脱出，会随页面滚动&lt;/li&gt;
&lt;li&gt;fixed：从文档流中脱出，不会随页面滚动&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;定位上下文：带有非static position的最近祖先元素，默认是body。&lt;/p&gt;

&lt;h3 id=&#34;display&#34;&gt;display&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;inline&lt;/li&gt;
&lt;li&gt;block&lt;/li&gt;
&lt;li&gt;none（空间会被回收）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最近支持越来越好的flexbox布局，值得有空仔细研究。&lt;/p&gt;

&lt;h3 id=&#34;background&#34;&gt;background&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;background-repeat&lt;/li&gt;
&lt;li&gt;background-size&lt;/li&gt;
&lt;li&gt;background-attachment&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;css3支持多张背景图片，先列出的在上层&lt;/p&gt;

&lt;p&gt;背景渐变&lt;/p&gt;

&lt;h2 id=&#34;字体和文本&#34;&gt;字体和文本&lt;/h2&gt;

&lt;p&gt;em相对最近的被设置过字体的祖先大小&lt;/p&gt;

&lt;p&gt;CSS3 rem相对root即body字体大小&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;text-indent&lt;/li&gt;
&lt;li&gt;text-align&lt;/li&gt;
&lt;li&gt;vertical-align: sub(下标) super(上标) top middle bottom&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Web字体&lt;/p&gt;

&lt;h2 id=&#34;界面组件&#34;&gt;界面组件&lt;/h2&gt;

&lt;p&gt;label的for属性可以把标签和控件关联起来&lt;/p&gt;

&lt;p&gt;fieldset表单域&lt;/p&gt;

&lt;p&gt;用section块级元素包裹label和input&lt;/p&gt;

&lt;h2 id=&#34;响应式布局&#34;&gt;响应式布局&lt;/h2&gt;

&lt;h3 id=&#34;媒体查询&#34;&gt;媒体查询&lt;/h3&gt;

&lt;p&gt;媒体类型：all handled print screen 等&lt;/p&gt;

&lt;p&gt;媒体特性：max-device-width max-width orientation&lt;/p&gt;

&lt;p&gt;and not all 等逻辑运算符&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>单页应用JWT身份认证</title>
      <link>https://dailydreamer.me/post/2016-04-09-spa-jwt-auth/</link>
      <pubDate>Sat, 09 Apr 2016 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/post/2016-04-09-spa-jwt-auth/</guid>
      <description>

&lt;p&gt;最近在开发一个单页应用，采用了前后端分离的策略，即后端只提供RESTful接口，前端进行路由，通过Ajax和后端交互。
为了保持RESTful服务的无状态，要避免使用sesseion来保存登录状态，可以使用token方式来进行认证。
这篇博客就来说一下利用JWT(JSON Web Tokens)进行身份认证，以及如何防范MITM，XSS与CSRF攻击。&lt;/p&gt;

&lt;h2 id=&#34;jwt-https-jwt-io-introduction&#34;&gt;&lt;a href=&#34;https://jwt.io/introduction/&#34;&gt;JWT&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;JWT是RFC 7159规范，利用JSON和一种可选的签名算法定义了一种紧凑且自恰的结构。
相比基于XML的SAML方式更加简单紧凑，节省流量且JSON格式方便处理。
相比基于session的认证方式不用在服务器端维护状态，易于扩展；不用查询数据库，性能更好；可以授权给别的应用。
缺点是实现过于复杂，很多语言库都没有实现完整的JWT规范。&lt;/p&gt;

&lt;p&gt;JWT由三部分组成，Header.Payload.Signature。&lt;/p&gt;

&lt;h3 id=&#34;header&#34;&gt;Header&lt;/h3&gt;

&lt;p&gt;Header包含签名算法和type，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;alg&amp;quot;: &amp;quot;HS256&amp;quot;,
  &amp;quot;typ&amp;quot;: &amp;quot;JWT&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Base64编码后即为Header。&lt;/p&gt;

&lt;h3 id=&#34;payload&#34;&gt;Payload&lt;/h3&gt;

&lt;p&gt;主体内容部分。有一些保留属性，如iss (issuer), exp (expiration time), sub (subject), aud (audience)等。也可以声明私有属性。&lt;/p&gt;

&lt;p&gt;如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;sub&amp;quot;: &amp;quot;1234567890&amp;quot;,
  &amp;quot;name&amp;quot;: &amp;quot;John Doe&amp;quot;,
  &amp;quot;admin&amp;quot;: true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Base64编码后即为Payload。&lt;/p&gt;

&lt;h3 id=&#34;signature&#34;&gt;Signature&lt;/h3&gt;

&lt;p&gt;签名部分，生成过程如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-js&#34;&gt;alg(
  base64UrlEncode(header) + &amp;quot;.&amp;quot; +
  base64UrlEncode(payload),
  secret)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中alg为Header中声明的签名算法，常用的如SHA256等。
结合secret校对签名可以保证JWT的完整性和不可伪造性。&lt;/p&gt;

&lt;h3 id=&#34;身份验证过程&#34;&gt;身份验证过程&lt;/h3&gt;

&lt;p&gt;后端API除了注册和登录外的需要身份验证的接口都对JWT签名进行验证，不通过则返回401 Unauthorized，保护API。
用户注册登录后生成JWT返回用户，用户访问受保护的API时需要随请求发送JWT至服务器端。&lt;/p&gt;

&lt;h2 id=&#34;两种常见的安全威胁&#34;&gt;两种常见的安全威胁&lt;/h2&gt;

&lt;p&gt;接下来看看单页应用开发中几种常见的安全威胁：MITM(Man-In-The-Middle)，XSS(Cross-site scripting)和CSRF(Cross Site Request Forgery)。&lt;/p&gt;

&lt;h3 id=&#34;mitm-https-www-owasp-org-index-php-man-in-the-middle-attack&#34;&gt;&lt;a href=&#34;https://www.owasp.org/index.php/Man-in-the-middle_attack&#34;&gt;MITM&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;MITM是指在数据传输过程中窃听甚至篡改线路中的数据，如窃听WIFI和ARP欺骗等等。
这里我们在应用层主要使用SSL加密，即HTTPS防范它。
在后端response的header的cookie设置&lt;code&gt;Secure&lt;/code&gt;字段，强制cookie使用HTTPS传输。&lt;/p&gt;

&lt;h3 id=&#34;xss-https-www-owasp-org-index-php-cross-site-scripting-28xss-29&#34;&gt;&lt;a href=&#34;https://www.owasp.org/index.php/Cross-site_Scripting_%28XSS%29&#34;&gt;XSS&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;XSS是指将恶意脚本注入站点，如在用户聊天框输入的地方输入如下内容&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;img src=x onerror=&amp;quot;alert(XSS!)&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果不经过滤就显示内容，那么该网页就会执行被注入的脚本，弹出一个alert。&lt;/p&gt;

&lt;p&gt;防范XSS的关键是不要信任任何用户提供的内容，对它们进行充分的过滤再使用。
并且在后端response的header的cookie设置&lt;code&gt;HttpOnly&lt;/code&gt;字段，禁止浏览器Javascript脚本操作cookie。&lt;/p&gt;

&lt;h3 id=&#34;csrf-https-www-owasp-org-index-php-cross-site-request-forgery-28csrf-29&#34;&gt;&lt;a href=&#34;https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29&#34;&gt;CSRF&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;CSRF利用了一个事实，即如&lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt;标签等发起的简单的GET请求是不被同源策略约束的。
如果攻击者在他的页面中加入一个标签如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;img src=&amp;quot;http://example.com/api/user&amp;quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引诱你访问这个界面后，该标签像example.com的user api发送GET请求，并且会附上你的example.com的cookie，那么攻击者就能得到你在example.com的user信息。&lt;/p&gt;

&lt;p&gt;要防范CSRF，主要有两种方式。
可以在后端的response的header中加入&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;白名单，限制跨域访问；
或者使用一些Synchronizer Token技术。
如在用户新建立一个sesseion时产生一个独有的Synchronizer Token，存储在表单的隐藏域、URL参数等地方，JWT的payload中也存储一份。
然后每次请求时前端都通过Javascript脚本发送Synchronizer Token,而这个token攻击者无法获取（除非先进行XSS）。
据此，后端就可以验证前端的身份非攻击者。&lt;/p&gt;

&lt;h2 id=&#34;前端jwt存储&#34;&gt;前端JWT存储&lt;/h2&gt;

&lt;p&gt;JWT存储有两种方式，localStorage和cookie。&lt;/p&gt;

&lt;h3 id=&#34;localstorage&#34;&gt;localStorage&lt;/h3&gt;

&lt;p&gt;后端返回JWT后，前端存储在localStorage中，每次请求时设置HTTP Authorization Header，使用Bearer scheme，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;HTTP/1.1

GET /api/user
Host: example.com
Authorization: Bearer Header.Payload.Signature
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;后端验证即可。&lt;/p&gt;

&lt;p&gt;存储在localStorage的优点是不使用cookie，避免了JWT被MIMT和CSRF攻击。缺点时localStorage可以被Javascript访问，容易被XSS攻击。&lt;/p&gt;

&lt;h3 id=&#34;cookie&#34;&gt;cookie&lt;/h3&gt;

&lt;p&gt;后端response的header设置Set-Cookie，如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-http&#34;&gt;HTTP/1.1 200 OK

Set-Cookie: token=Header.Payload.Signature Secure; HttpOnly;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;前端发器跨域请求时，正确设置(见上一篇blog)后会同时附带cookie，后端验证即可。&lt;/p&gt;

&lt;p&gt;存储在cookie的优点是在设置了&lt;code&gt;Secure; HttpOnly;&lt;/code&gt;后防范了XSS和MIMT攻击，但是容易收到CSRF攻击。&lt;/p&gt;

&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;

&lt;p&gt;JWT提供了一种很好的身份验证方式，至于存储在哪里向来有很多争论，这是一个权衡取舍的过程。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>CORS解决单页应用跨域问题</title>
      <link>https://dailydreamer.me/post/2016-04-08-cors-solve-same-origin-policy-problem/</link>
      <pubDate>Fri, 08 Apr 2016 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/post/2016-04-08-cors-solve-same-origin-policy-problem/</guid>
      <description>

&lt;h2 id=&#34;同源策略-https-developer-mozilla-org-en-us-docs-web-security-same-origin-policy&#34;&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy&#34;&gt;同源策略&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;最近在开发一个单页应用，采用了前后端分离的策略，即后端只提供RESTful接口，前端进行路由，通过Ajax和后端交互。
这时前端和后端部署在不同的服务器上。
而浏览器为了安全，运行在浏览器中的Javascript脚本受到同源策略限制。&lt;/p&gt;

&lt;p&gt;同源是指协议+主机名+端口号全部相同，称为同源。
详细见下表，是跟&amp;rdquo;&lt;a href=&#34;http://www.example.com/dir/page.html&amp;quot;做比较。&#34;&gt;http://www.example.com/dir/page.html&amp;quot;做比较。&lt;/a&gt;&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;left&#34;&gt;Compared URL&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Outcome&lt;/th&gt;
&lt;th align=&#34;left&#34;&gt;Reason&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;http://www.example.com/dir/page2.html&#34;&gt;http://www.example.com/dir/page2.html&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Success&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Same protocol, host and port&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;http://www.example.com/dir2/other.html&#34;&gt;http://www.example.com/dir2/other.html&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Success&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Same protocol, host and port&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;http://username:password@www.example.com/dir2/other.html&#34;&gt;http://username:password@www.example.com/dir2/other.html&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Success&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Same protocol, host and port&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;http://www.example.com:81/dir/other.html&#34;&gt;http://www.example.com:81/dir/other.html&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Failure&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Same protocol and host but different port&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;https://www.example.com/dir/other.html&#34;&gt;https://www.example.com/dir/other.html&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Failure&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Different protocol&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;http://en.example.com/dir/other.html&#34;&gt;http://en.example.com/dir/other.html&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Failure&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Different host&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;http://example.com/dir/other.html&#34;&gt;http://example.com/dir/other.html&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Failure&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Different host (exact match required)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;http://v2.www.example.com/dir/other.html&#34;&gt;http://v2.www.example.com/dir/other.html&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Failure&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Different host (exact match required)&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;left&#34;&gt;&lt;a href=&#34;http://www.example.com:80/dir/other.html&#34;&gt;http://www.example.com:80/dir/other.html&lt;/a&gt;&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Depends&lt;/td&gt;
&lt;td align=&#34;left&#34;&gt;Port explicit. Depends on implementation in browser&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Javascript不能访问非同源下的资源，如cookie，localstorge等，这也意味着ajax请求后返回的数据会被浏览器认为是非同源而禁止Javascript操作。
通常的解决方法有JSONP(JSON with Padding)和CORS(Cross-origin resource sharing)。
当然如果要求实时性的话也可以考虑WebSocket协议，这点本文不展开。&lt;/p&gt;

&lt;h2 id=&#34;jsonp-https-en-wikipedia-org-wiki-jsonp&#34;&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/JSONP&#34;&gt;JSONP&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;HTML标准里的&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签，它可以调用部署在CDN上或其他服务器上的非同源Javascript。
JSONP实际上是利用了这一点，和服务器端约定，在发送请求时加入了一个回调函数的参数。
如Jquery中设置参数&lt;code&gt;dataType: &amp;quot;jsonp&amp;quot;&lt;/code&gt;后，请求相当于插入页面如下标签&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;script src=&amp;quot;http://www.example.net/api/example?callback=mycallback&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务器端返回的payload为&lt;code&gt;mycallback(data)&lt;/code&gt;，通过&lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt;标签执行，就完成了ajax请求。&lt;/p&gt;

&lt;p&gt;JSONP的优点是实现简单，兼容性很好。
缺点是只支持GET请求。&lt;/p&gt;

&lt;h2 id=&#34;cors-https-developer-mozilla-org-en-us-docs-web-http-access-control-cors&#34;&gt;&lt;a href=&#34;https://developer.mozilla.org/en-US/docs/Web/HTTP/Access_control_CORS&#34;&gt;CORS&lt;/a&gt;&lt;/h2&gt;

&lt;p&gt;CORS是W3C推荐的跨域HTTP请求的新机制，它可以支持如下请求：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;XMLHttpRequest(即ajax请求)&lt;/li&gt;
&lt;li&gt;Web Fonts&lt;/li&gt;
&lt;li&gt;WebGL textures&lt;/li&gt;
&lt;li&gt;canvas中drawImage产生的Images/video frames&lt;/li&gt;
&lt;li&gt;CSS&lt;/li&gt;
&lt;li&gt;Scripts&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;简单请求&#34;&gt;简单请求&lt;/h3&gt;

&lt;p&gt;简单请求，是指满足如下条件的请求：&lt;/p&gt;

&lt;p&gt;只允许如下方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;GET&lt;/li&gt;
&lt;li&gt;HEAD&lt;/li&gt;
&lt;li&gt;POST&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;除了浏览器自动设置的属性（如Connection, User-Agent等), 只允许设置如下头部属性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Accept&lt;/li&gt;
&lt;li&gt;Accept-Language&lt;/li&gt;
&lt;li&gt;Content-Language&lt;/li&gt;
&lt;li&gt;Content-Type&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;只允许如下Content-Type值:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;application/x-www-form-urlencoded&lt;/li&gt;
&lt;li&gt;multipart/form-data&lt;/li&gt;
&lt;li&gt;text/plain&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;对于简单请求，要允许CORS，需要在后端返回的response的header中设置&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;允许前端服务器地址的ajax请求，可以使用通配符或白名单。
如&lt;code&gt;Access-Control-Allow-Origin: *&lt;/code&gt;允许所有跨域请求，&lt;code&gt;Access-Control-Allow-Origin: http://example.com&lt;/code&gt;允许前端服务器example.com的跨域请求。&lt;/p&gt;

&lt;p&gt;发送CORS跨域请求默认不带cookie。
可以设置request的header中xhr对象&lt;code&gt;withCredentials: true&lt;/code&gt;一同发送cookie，同时后端返回的response的header中设置&lt;code&gt;Access-Control-Allow-Credentials: true&lt;/code&gt;接收cookie。
注意使用cookie时&lt;code&gt;Access-Control-Allow-Origin&lt;/code&gt;的值不能是通配符&lt;code&gt;*&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&#34;preflighted-requests&#34;&gt;Preflighted requests&lt;/h3&gt;

&lt;p&gt;除了简单请求外的请求都是复杂请求。
在发送复杂请求之前需要先发送一个OPTIONS方法的Preflighted requests，后端确认安全后再发送正式请求。
具体设置可以参考&lt;a href=&#34;https://www.w3.org/TR/cors/&#34;&gt;W3C推荐标准&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>一次与CTF的邂逅</title>
      <link>https://dailydreamer.me/post/2015-11-23-meet-ctf/</link>
      <pubDate>Mon, 23 Nov 2015 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/post/2015-11-23-meet-ctf/</guid>
      <description>

&lt;p&gt;机缘巧合做了两道CTF二进制题目，谨以此为记。&lt;/p&gt;

&lt;h3 id=&#34;第一题-recho&#34;&gt;第一题 recho&lt;/h3&gt;

&lt;p&gt;主要参考&lt;a href=&#34;https://blog.skullsecurity.org/2013/ropasaurusrex-a-primer-on-return-oriented-programming&#34;&gt;这篇博客&lt;/a&gt;，ruby实现，也有人推荐了&lt;a href=&#34;http://drops.wooyun.org/tips/6597&#34;&gt;这篇&lt;/a&gt;python实现版，使用了&lt;code&gt;pwntools&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;第一题中&lt;code&gt;handle()&lt;/code&gt;函数&lt;code&gt;buf&lt;/code&gt;大小&lt;code&gt;256Byte&lt;/code&gt;，但是&lt;code&gt;recv_line()&lt;/code&gt;函数接受用户输入没有限制长度，存在&lt;code&gt;BOF&lt;/code&gt;漏洞可以利用。&lt;/p&gt;

&lt;p&gt;为了方便本地调试，将源代码中关于&lt;code&gt;drop_priv()&lt;/code&gt;相关函数去除后，本地编译。&lt;/p&gt;

&lt;p&gt;为了能够在64位linux上编译和执行32位文件，需要安装32位环境。以Ubuntu14.04为例，执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;sudo dpkg --add-architecture i386
sudo apt-get update
sudo apt-get install libc6:i386 libncurses5:i386 libstdc++6:i386 gcc-multilib
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即可。&lt;/p&gt;

&lt;p&gt;编译时使用命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;gcc -fno-stack-protector -g -o recholocal -m32 recholocal.c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;注意使用&lt;code&gt;-m32&lt;/code&gt;参数编译成32位，&lt;code&gt;-fno-stack-protector&lt;/code&gt;关闭stack canary检测，&lt;code&gt;-g&lt;/code&gt;方便gdb调试。&lt;/p&gt;

&lt;p&gt;运行&lt;code&gt;./recholocal&lt;/code&gt;后通过命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ps -aux | grep recholocal
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;查看其进程号，通过&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;gdb atach pid
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;来调试该进程。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;set follow-fork-mode child
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以使gdb在程序&lt;code&gt;fork()&lt;/code&gt;后跟随子进程。&lt;/p&gt;

&lt;p&gt;在程序中找到&lt;code&gt;recvline()&lt;/code&gt;和&lt;code&gt;sendlen()&lt;/code&gt;，使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;objdump -d recholocal | grep recvline
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;获取地址，使用他们来对内存进行写和读。
注意&lt;code&gt;recv_line&lt;/code&gt;最后以&lt;code&gt;\n&lt;/code&gt;结束。
还有程序最开始调用的&lt;code&gt;sendstr()&lt;/code&gt;函数会将是将&lt;code&gt;payload&lt;/code&gt;的&lt;code&gt;strlen()&lt;/code&gt;长度发送，如果&lt;code&gt;payload&lt;/code&gt;中有&lt;code&gt;0x00&lt;/code&gt;就会被截断发送。&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;objdump -x recholocal&lt;/code&gt;可以查看各个section的位置和布局，找到一个可读可写又足够大的section来存放我们的字符串参数，如&lt;code&gt;.bss&lt;/code&gt;或&lt;code&gt;.dynamic&lt;/code&gt;等。
发现&lt;code&gt;.dynamic&lt;/code&gt;的位置是&lt;code&gt;0x0804a10c&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;为了对付ALSR，需要先知道&lt;code&gt;libc&lt;/code&gt;中某个函数的运行时地址，使用&lt;code&gt;sendlen()&lt;/code&gt;将其发送过来，再加上&lt;code&gt;system()&lt;/code&gt;相对这个函数的偏移，写入某个函数&lt;code&gt;got&lt;/code&gt;表项，在调用该函数就是相当于调用了&lt;code&gt;system()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;使用&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;objdump -R recholocal | grep __libc_start_main
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;发现&lt;code&gt;__libc_start_main()&lt;/code&gt;的&lt;code&gt;got&lt;/code&gt;表项地址为&lt;code&gt;0x0804a040&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;ldd recholocal
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可发现本地链接库&lt;code&gt;libc.so.6&lt;/code&gt;的位置，对其&lt;code&gt;objdump&lt;/code&gt;后找到&lt;code&gt;__libc_start_main()&lt;/code&gt;和&lt;code&gt;__libc_system()&lt;/code&gt;的地址，计算其偏移。&lt;/p&gt;

&lt;p&gt;使用&lt;code&gt;objdump -d recholocal | egrep &#39;pop|ret&#39;&lt;/code&gt;发现&lt;code&gt;ppppr&lt;/code&gt;如下&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;8048d1c:	5b                   	pop    %ebx
8048d1d:	5e                   	pop    %esi
8048d1e:	5f                   	pop    %edi
8048d1f:	5d                   	pop    %ebp
8048d20:	c3                   	ret   
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在堆砌堆栈时需要使用，使用时截取需要部分即可。&lt;/p&gt;

&lt;p&gt;本地跑通后将地址改为服务器端地址即可。&lt;/p&gt;

&lt;p&gt;刚开始本来想利用&lt;a href=&#34;http://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet&#34;&gt;这篇博客&lt;/a&gt;中的方法获取reverse shell，后来发现由于recho程序中将标准输入输出都复制到了socket中，所以只需&lt;code&gt;cat ～/flag&lt;/code&gt;然后再&lt;code&gt;read()&lt;/code&gt;出来即可。&lt;/p&gt;

&lt;h3 id=&#34;第二题-weapon-shop&#34;&gt;第二题 weapon_shop&lt;/h3&gt;

&lt;p&gt;这一题只有二进制文件，先使用IDA Pro反编译，按&lt;code&gt;F5&lt;/code&gt;可以看到部分C伪码，结合程序对函数进行理解。&lt;/p&gt;

&lt;p&gt;可以看到该程序输入时都限制了长度，因此不方便&lt;code&gt;BOF&lt;/code&gt;。
但是找到在输入&lt;code&gt;Credit Card Number&lt;/code&gt;时长度限制为&lt;code&gt;200Byte&lt;/code&gt;，而且写入了可执行的&lt;code&gt;.bss&lt;/code&gt;段，因此可以在这里写入一些&lt;code&gt;shellcode&lt;/code&gt;，地址为&lt;code&gt;0x0804b1e0&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;同时注意到在买武器过程中输入数字，使用了&lt;code&gt;strtol()&lt;/code&gt;函数，它会扫描字符串，跳过前面的空格，将后面的字符转换成数字。而函数只检查了第一个字符不是负号，以及不大于8，因此可以输入空格加一个任意负数。
后面它使用数组起始地址加这个数得到的地址对其自增，因此输入一个合理的偏移量就可以对任意高于该数组起始地址的地址进行自增。
该数组位于主循环函数的栈上，因此可以对主循环函数的返回地址改写位&lt;code&gt;shellcode&lt;/code&gt;所在的地址。
注意该自增只增加一个字节，因此需要对返回地址每个字节分别自增。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;shellcode&lt;/code&gt;最后选取了拿到&lt;code&gt;/bin/sh&lt;/code&gt;的&lt;code&gt;shellcode&lt;/code&gt;。
因此最后使用了&lt;code&gt;pwntools&lt;/code&gt;里的&lt;code&gt;interactive()&lt;/code&gt;函数和远端&lt;code&gt;shell&lt;/code&gt;进行交互。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>多个github账号的ssh key切换</title>
      <link>https://dailydreamer.me/post/2015-10-30-ssh-config/</link>
      <pubDate>Fri, 30 Oct 2015 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/post/2015-10-30-ssh-config/</guid>
      <description>

&lt;p&gt;当拥有多个github账号并且想通过ssh方式同步代码时，就需要在多个账号的ssh key间切换。&lt;/p&gt;

&lt;h2 id=&#34;github多个账号ssh-key切换&#34;&gt;github多个账号ssh key切换&lt;/h2&gt;

&lt;h3 id=&#34;配置ssh的config文件&#34;&gt;配置ssh的config文件&lt;/h3&gt;

&lt;p&gt;使用&lt;code&gt;ssh-keygen -t rsa -C &amp;quot;youremail@xxx.com&amp;quot;&lt;/code&gt;生成两个ssh key之后，在~/.ssh/下添加一个config文件，内容如下:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Host github.com
  HostName github.com
  PreferredAuthentications publickey
  IdentityFile ~/.ssh/id_rsa
Host second.github.com
  HostName github.com
  PreferredAuthentications publickey
  IdentityFile ~/.ssh/id_rsa_second
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;设置远程仓库的ssh地址&#34;&gt;设置远程仓库的ssh地址&lt;/h3&gt;

&lt;p&gt;只需要让ssh的目标主机地址变为你写的Host即可。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;git remote add origin git@second.github.com:myname/myrepo.git
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;更加深入的利用ssh config文件可以参考&lt;a href=&#34;http://nerderati.com/2011/03/17/simplify-your-life-with-an-ssh-config-file/&#34;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>WPF全局隐藏鼠标</title>
      <link>https://dailydreamer.me/post/2015-06-29-hiding-mouse-globally-in-wpf/</link>
      <pubDate>Mon, 29 Jun 2015 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/post/2015-06-29-hiding-mouse-globally-in-wpf/</guid>
      <description>&lt;p&gt;前些日子使用WPF实现了一个填平两个屏幕间缝隙的小程序，在那里面需要让光标在两个屏幕间的时候将其隐藏。
在一个程序内部隐藏鼠标很容易，在WPF中只需设置&lt;code&gt;Mouse.OverrideCursor = Cursors.None&lt;/code&gt;。
但是当程序最小化后鼠标还能隐藏着实费了一番功夫。
大致有如下几种思路。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;将系统的光标图标设置为一个blank.cur的空图标，要显示时再替换回来，这样就可以全局隐藏鼠标，具体方法可以看&lt;a href=&#34;http://stackoverflow.com/questions/10541014/hiding-system-cursor&#34;&gt;这里&lt;/a&gt;。
但是这种方法有一些问题，一个是需要将系统所有状态的光标图标都替换为空图标，十分繁琐；
而且非常危险，因为一旦你的程序在隐藏鼠标时崩溃，那么鼠标就消失了！
只有重启才能重新显示鼠标。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;要隐藏鼠标时将鼠标的位置一直设置在右下角。
这样虽然看不见鼠标了，但是有时会触发侧边栏，尤其是Win8的右边栏；
同时无法知道用户此时已经将光标移动到哪里了，因此也不是非常好用。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;最后终于找到了一种十分讨巧的方法。
就是在要隐藏光标的范围内新建一个透明窗口，然后在这个窗口上将光标隐藏。
大致代码如下：&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&#34;language-cs&#34;&gt;Window cursorWin;
private void cursorWinInit()
{
    cursorWin = new Window();
    cursorWin.Left = bound - (W + hideBuffer);
    cursorWin.Top = 0;
    cursorWin.Width = 2 * (W + hideBuffer);
    cursorWin.Height = maxHeight;
    cursorWin.ShowInTaskbar = false;            //禁止在任务栏显示
    cursorWin.WindowStyle = WindowStyle.None;   //无边框
    cursorWin.AllowsTransparency = true;        //透明
    cursorWin.Topmost = true;                   //置顶
    cursorWin.Background = new SolidColorBrush(Color.FromArgb(1, 0, 0, 0));     //透明
}
private void myHideCursor()
{
    cursorWin.Dispatcher.Invoke(
        new Action(
            delegate
            {
                cursorWin.Show();
                Mouse.OverrideCursor = Cursors.None;
            }));
}

private void myShowCursor()
{
    cursorWin.Dispatcher.Invoke(
        new Action(
            delegate
            {
                cursorWin.Hide();
                Mouse.OverrideCursor = null;
            }));
}
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>UNIX编程艺术</title>
      <link>https://dailydreamer.me/post/2015-06-28-unix-programming-art/</link>
      <pubDate>Sun, 28 Jun 2015 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/post/2015-06-28-unix-programming-art/</guid>
      <description>

&lt;p&gt;这本书极为经典，虽然后半部分的细节有些过时，但是前面的哲学影响深远且富有启发性。&lt;/p&gt;

&lt;h2 id=&#34;哲学&#34;&gt;哲学&lt;/h2&gt;

&lt;p&gt;UNIX有它独有的文化和哲学，它富有生命力且影响深远。UNIX诞生于1969年，而今天化身为Linux、BSD、MacOS X等，应用广泛且强大。&lt;/p&gt;

&lt;p&gt;UNIX文件在字节层次上再无结构，文件删除了无法恢复，作业控制有欠精致，命名方式混乱。这些都是UNIX的缺点。&lt;/p&gt;

&lt;p&gt;最大的争议在于，&lt;strong&gt;提供机制，而不是策略&lt;/strong&gt;。
比如X Window，提供一套极端通用的图形操作，将界面的观感(策略)推后到应用层。
这使得UNIX可以提供很多行为选项和令人眼花缭乱的定制功能。
然而它的代价就是当用户“可以”设置自己的策略时，他们“必须”设置自己的策略。
这使得UNIX失去了很多非技术用户，但是策略相对短寿，机制才会长存。
只提供机制才能使得UNIX长久保鲜。&lt;/p&gt;

&lt;p&gt;同时，UNIX还有着及其丰富和优秀的外围文化。
开源软件，跨平台可移植和开放标准(IEEE的可移植操作系统标准POS很快被大家加后缀变成了POSIX)，Internet和TCP/IP协议，开源社区，从头到脚的灵活性(在其他系统中，完成设计者预见的任务容易，但是设计者没有预料到的就很难)，以及UNIX hack很有乐趣。&lt;/p&gt;

&lt;p&gt;UNIX哲学起源与Ken Thompson早期关于如何设计一个服务接口简洁、小巧精干的操作系统的思考，一路成长且博采众长。
UNIX管道的发明人Doug Mcllroy总结，UNIX哲学是一个程序只做一件事，并做好。程序要能协作。
程序要能处理文本流，因为这是最通用的接口。整体上，UNIX哲学可以概括为一下几点：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;模块原则&lt;/strong&gt;：使用简洁的接口拼合简单的部件&lt;/p&gt;

&lt;p&gt;编制复杂软件而又不至于一败涂地的唯一非方法就是降低其整体复杂度，用清晰的接口把若干简单的模块组合成一个复杂的软件。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;清晰原则&lt;/strong&gt;：清晰胜于机巧&lt;/p&gt;

&lt;p&gt;些程序时，要想到你不是写给计算机看，而是写给人看的。优雅而清晰的代码不仅不容易崩溃，而且更易于让后来的修改者立刻理解。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;组合原则&lt;/strong&gt;：设计时考虑拼接&lt;/p&gt;

&lt;p&gt;在输入输出方面，UNIX传统极力提倡采用简单、文本化、面向流、设备无关的格式，否则很难和其它程序衔接。要想让程序具有组合性，就要使程序彼此独立。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;分离原则&lt;/strong&gt;：策略同机制分离，接口同引擎分离&lt;/p&gt;

&lt;p&gt;策略短寿，机制长存。在探索新策略的时候尽量不要打破机制，这样也可以为机制编写更好的测试。&lt;/p&gt;

&lt;p&gt;在GUI之外也可以应用这个原则，如Emacs编辑器使用内嵌的脚本语言Lisp解释器来控制用C编写的编辑原语操作。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;简洁原则&lt;/strong&gt;：设计要简洁，复杂度要低&lt;/p&gt;

&lt;p&gt;复杂的东西代价更高，bug更多。以简洁为美，总设法将程序系统分解成几个能够协作的小部分。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;透明性原则&lt;/strong&gt;：设计要可见，以便审查和调试。&lt;/p&gt;

&lt;p&gt;透明性是说一眼能看出软件是在做什么以及怎样做的，显见性是说程序带有监视和显示内部状态的功能。尽早设置调试选项。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;健壮原则&lt;/strong&gt;：健壮源于透明与简洁&lt;/p&gt;

&lt;p&gt;健壮性指在超出设计者预想外的条件下也能运行良好。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;表示原则&lt;/strong&gt;：把知识叠入数据以求逻辑质朴而健壮。&lt;/p&gt;

&lt;p&gt;数据比变成逻辑更容易驾驭。主动将代码的复杂度转移到数据之中去。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;通俗原则&lt;/strong&gt;：接口设计避免标新立异&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;缄默原则&lt;/strong&gt;：如果一个程序没什么好说的，就保持沉默&lt;/p&gt;

&lt;p&gt;只输出重要的东西。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;补救原则&lt;/strong&gt;：出现异常时，马上退出并给出足量错误信息&lt;/p&gt;

&lt;p&gt;“宽容的收，谨慎的发”。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;经济原则&lt;/strong&gt;：宁花机器一分，不花程序员一秒&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;生成原则&lt;/strong&gt;：避免手工hack，尽量编写程序去生成程序&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;优化原则&lt;/strong&gt;：雕琢之前先有型&lt;/p&gt;

&lt;p&gt;先制作原型，再精雕细琢。从原型中寻找通过牺牲最小局部简洁性而获得较大性能提升的地方。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;多样原则&lt;/strong&gt;：绝不相信所谓“不二法门”断言&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;strong&gt;扩展原则&lt;/strong&gt;：设计着眼未来，未来总比预想的快&lt;/p&gt;

&lt;p&gt;一言以蔽之，就是KISS，Keep it simple and stupid。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;历史-双流记&#34;&gt;历史————双流记&lt;/h2&gt;

&lt;p&gt;忘记过去的人，注定要重蹈覆辙。&lt;/p&gt;

&lt;h2 id=&#34;对比-unix哲学同其他哲学的比较&#34;&gt;对比：UNIX哲学同其他哲学的比较&lt;/h2&gt;

&lt;p&gt;UNIX风格，一切皆文件，以及在此之上的管道概念。&lt;/p&gt;

&lt;p&gt;UNIX中，进程生成代价低，并且有简便的进程间通讯。使得众多小工具、管道和过滤器组成了一个均衡系统。
而反UNIX系统必须编写庞大的单个程序，并且进程间通讯要知晓彼此的细节，否则就只能采取低效不安去的方式。&lt;/p&gt;

&lt;p&gt;UNIX中内部边界清晰。
有多用户权限，以及把设计关键安全性的功能限制在尽可能小的可信代码块上。
即使shell也不是什么特权程序。&lt;/p&gt;

&lt;p&gt;UNIX文件不是靠后缀名识别的，没有文件属性，但是可以通过magic number来识别文件。
文件属性在管道中会引发棘手的问题，对文件属性的支持会使程序员使用不透明的文件格式。&lt;/p&gt;

&lt;p&gt;如果不像UNIX强调CLI命令行界面，那么程序设计不会考虑以未预料的方式合作，难以实现远程系统管理，守护进程难以实现。&lt;/p&gt;

&lt;p&gt;UNIX开发门槛很低，有大量廉价工具和简单接口，开创了轻松编程的先河。&lt;/p&gt;

&lt;h2 id=&#34;模块性-保持清晰-保持简洁&#34;&gt;模块性，保持清晰，保持简洁&lt;/h2&gt;

&lt;h3 id=&#34;封装和最佳模块大小&#34;&gt;封装和最佳模块大小&lt;/h3&gt;

&lt;p&gt;模块太小时，复杂性全在于接口，阅读代码需要知道大量接口。模块太大时，模块内部代码bug太多。这都不是很好。&lt;/p&gt;

&lt;h3 id=&#34;紧凑型和正交性&#34;&gt;紧凑型和正交性&lt;/h3&gt;

&lt;p&gt;紧凑性是指一个设计内否装进人脑，有经验的用户是否不需要手册。
不要有内部功能冗余，否则会出现功能子集成为“方言”，“方言”之间相互不能理解。&lt;/p&gt;

&lt;p&gt;正交性是说每一个动作只改变一件事而不影响其他。正交性缩短了测试和开发的时间。重构的原则性目标就是提高正交性。&lt;/p&gt;

&lt;p&gt;任何一个知识点在系统内都应当有一个唯一、权威的描述。&lt;/p&gt;

&lt;p&gt;围绕“解决一个定义明确的问题”的强核心算法组织设计，避免臆断和捏造。&lt;/p&gt;

&lt;h3 id=&#34;软件是多层的&#34;&gt;软件是多层的&lt;/h3&gt;

&lt;p&gt;纯粹自顶向下设计和自底向上设计都不好，可以结合使用。
但是需要胶合层来协调策略和机制。&lt;/p&gt;

&lt;p&gt;C语言作为结构汇编程序是薄胶合层的经典代表。
完美之道，不在无可增加，而在无可减少。&lt;/p&gt;

&lt;p&gt;UNIX强烈倾向于把程序分解成由胶合层连接的库集合。&lt;/p&gt;

&lt;p&gt;OO经常被过分推崇为解决软件复杂性的唯一方法，这违背了多样性原则。&lt;/p&gt;

&lt;p&gt;OO在其取得成功的领域(GUI，仿真，图形)之所以成功的主要原因之一是因为在这些领域里很难弄错类型的问题本体。&lt;/p&gt;

&lt;h2 id=&#34;文本化-好协议产生好实践&#34;&gt;文本化：好协议产生好实践&lt;/h2&gt;

&lt;h3 id=&#34;文本化的重要性&#34;&gt;文本化的重要性&lt;/h3&gt;

&lt;p&gt;文本流非常通用，并且通过压缩文本可以有很好的性能。&lt;/p&gt;

&lt;p&gt;二进制格式限制了位数，文本可拓展性更强。&lt;/p&gt;

&lt;h3 id=&#34;数据文件元格式&#34;&gt;数据文件元格式&lt;/h3&gt;

&lt;p&gt;尽可能使用元格式而不是标新立异。&lt;/p&gt;

&lt;p&gt;DSV，分隔符分隔值。如/etc/password用冒号分隔，反斜杠转义。&lt;/p&gt;

&lt;p&gt;RFC 822，电子邮件格式。HTTP1.1也是这种格式。属性每行一个，冒号接空白结束。&lt;/p&gt;

&lt;p&gt;Cookie-Jar和Record-Jar，用%%\n结束。&lt;/p&gt;

&lt;p&gt;XML，适合复杂数据格式，但是不能被传统UNIX工具解析。&lt;/p&gt;

&lt;p&gt;UNIX文本文件的约定：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;如果可能，以换行符结束的每一行只存一个记录。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果可能，每行不超过80个字符。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用#引入注释。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;支持反斜杠约定。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用冒号或连续空白作为分隔符。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不要过分区别TAB和空格(令人头疼的python缩进)。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对于复杂的记录，使用节格式。使用%%\n作为分隔符。并支持连续行(如Cookie-Jar)。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;包含版本号，或将格式设计成相互独立的自描述字节块(如PNG)。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;不要仅对文件的一部分进行压缩或二进制编码。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;应用协议设计&#34;&gt;应用协议设计&lt;/h3&gt;

&lt;p&gt;//TODO 留着以后看。。。&lt;/p&gt;

&lt;h2 id=&#34;透明性-来点儿光&#34;&gt;透明性，来点儿光&lt;/h2&gt;

&lt;p&gt;透明性是说知道程序在干什么，可显性是说知道程序怎么干的。&lt;/p&gt;

&lt;p&gt;优雅的代码不仅正确而且显然正确。优雅的代码不仅将算法传递给计算机而且将见解传递和信心传递给阅读代码的人。&lt;/p&gt;

&lt;p&gt;编写透明可显的系统节省的精力，将来可能就是自己的财富。&lt;/p&gt;

&lt;h3 id=&#34;为透明性和可显性设计&#34;&gt;为透明性和可显性设计&lt;/h3&gt;

&lt;p&gt;要追求代码的透明，最有效的方法很简单，就是不要在具体操作的代码上加上太多抽象层。&lt;/p&gt;

&lt;p&gt;可以默认隐藏细节，但不要使其无法被访问。&lt;/p&gt;

&lt;p&gt;反例，不透明的Windows注册表，注册表蠕变。&lt;/p&gt;

&lt;h3 id=&#34;为可维护性设计&#34;&gt;为可维护性设计&lt;/h3&gt;

&lt;p&gt;选择简单的算法，提供开发者手册。&lt;/p&gt;

&lt;h2 id=&#34;多道程序设计-分离进程为独立的功能&#34;&gt;多道程序设计：分离进程为独立的功能&lt;/h2&gt;

&lt;p&gt;做单件事并做好。&lt;/p&gt;

&lt;p&gt;真正挑战的不是协议语法而是协议逻辑。&lt;/p&gt;

&lt;h3 id=&#34;从性能调整中分离复杂度控制&#34;&gt;从性能调整中分离复杂度控制&lt;/h3&gt;

&lt;p&gt;除非万不得已(性能太差)尽量避免使用线程。&lt;/p&gt;

&lt;p&gt;将程序划分成多个子进程可以使需要特权的代码块尽量少。&lt;/p&gt;

&lt;h3 id=&#34;unix-ipc方法分类&#34;&gt;UNIX IPC方法分类&lt;/h3&gt;

&lt;p&gt;将任务转给专门程序。UNIX shellout。&lt;/p&gt;

&lt;p&gt;管道，重定向和过滤器。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;管道中所有阶段程序都是并发执行的。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;管道的缺点或局限是单向性。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;包装器。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;隐藏shell管线的复杂细节。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;安全性包装器。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;从进程。&lt;/p&gt;

&lt;p&gt;对等进程间通信。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;临时文件。用文件名包含$$，即PID保证文件名唯一。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;信号。需要信号的程序会向var/run写入pidfile。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;套接字。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;共享内存。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;要避免的问题和方法&#34;&gt;要避免的问题和方法&lt;/h3&gt;

&lt;p&gt;废弃的UNIX IPC方法。&lt;/p&gt;

&lt;p&gt;远程过程调用。不够透明可显。&lt;/p&gt;

&lt;p&gt;线程。同步互斥锁开销大且bug多。&lt;/p&gt;

&lt;h2 id=&#34;微型语言-寻找唱歌的音符&#34;&gt;微型语言：寻找唱歌的音符&lt;/h2&gt;

&lt;p&gt;更高级的语言可以使用更少的行数完成更多任务，也意味着更少的bug。&lt;/p&gt;

&lt;p&gt;UNIX包容小型的、为专门领域特制、大量减少程序行数的语言。&lt;/p&gt;

&lt;p&gt;//TODO 留着以后看。。。&lt;/p&gt;

&lt;h2 id=&#34;生成-提升规格说明的层次&#34;&gt;生成：提升规格说明的层次&lt;/h2&gt;

&lt;p&gt;尽可能把设计的复杂度从代码转移到数据中去。&lt;/p&gt;

&lt;h2 id=&#34;配置-迈出正确的第一步&#34;&gt;配置：迈出正确的第一步&lt;/h2&gt;

&lt;h3 id=&#34;什么应该是可配置的&#34;&gt;什么应该是可配置的&lt;/h3&gt;

&lt;p&gt;对于能够进行可靠检测的东西，就不要提供配置开关。&lt;/p&gt;

&lt;p&gt;提高程序适应能力，除非这样做会产生超过0.7秒延时。&lt;/p&gt;

&lt;p&gt;增加一个配置选项，就会减少测试覆盖率。&lt;/p&gt;

&lt;h3 id=&#34;配置在哪里&#34;&gt;配置在哪里&lt;/h3&gt;

&lt;p&gt;局部覆盖全局。&lt;/p&gt;

&lt;p&gt;使用同参数选项预期寿命最匹配的机制。&lt;/p&gt;

&lt;h3 id=&#34;命令行选项&#34;&gt;命令行选项&lt;/h3&gt;

&lt;p&gt;传统UNIX风格如&lt;code&gt;-ab&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;GNU风格如`&lt;code&gt;--a --b&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&#34;接口-unix环境下的用户接口设计模式&#34;&gt;接口：UNIX环境下的用户接口设计模式&lt;/h2&gt;

&lt;p&gt;最小立异原则。新颖性提高了用户与接口最初几次的交互成本。仔细掂量你的折衷。&lt;/p&gt;

&lt;p&gt;提倡以共生和委派策略提高代码复用，降低复杂度。&lt;/p&gt;

&lt;p&gt;UNIX接口历史。面向行的，面向字符阵列的，和基于X的。&lt;/p&gt;

&lt;p&gt;接口设计在这些条件间权衡：简洁，表现力，易用，透明，脚本化能力。&lt;/p&gt;

&lt;p&gt;现代接口应当既支持CLI又支持可视接口，它们各有优缺点。&lt;/p&gt;

&lt;p&gt;UNIX程序员愿意使接口富有表现力和可配置。&lt;/p&gt;

&lt;p&gt;接口设计模式：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;过滤器：catlike型，宽进严出，不需要的也不丢弃，绝不增加无用数据。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;canstrip模式，如clear。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;源模式，如ls。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;引擎和接口分离。MVC模式。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;基于语言的接口。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;等等各种模式。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;网页浏览器作为通用前端，避免了后端大量GUI冗余代码。&lt;/p&gt;

&lt;h2 id=&#34;优化&#34;&gt;优化&lt;/h2&gt;

&lt;p&gt;知道何时不去优化。&lt;/p&gt;

&lt;p&gt;最有效的优化往往是优化以外的事情，如清晰干净的设计。&lt;/p&gt;

&lt;p&gt;最强大的优化技术是不优化。摩尔定律的指数效应。不值得为常数项优化。&lt;/p&gt;

&lt;p&gt;先估量，后优化。明确瓶颈所在，使用性能评估工具。&lt;/p&gt;

&lt;p&gt;小即是美，尽量将核心代码和数据结构放进缓存。&lt;/p&gt;

&lt;p&gt;降低延时。可以批处理、重叠操作、缓存。&lt;/p&gt;

&lt;h2 id=&#34;复杂度-尽可能简单-但别简单过了头&#34;&gt;复杂度：尽可能简单，但别简单过了头&lt;/h2&gt;

&lt;h3 id=&#34;谈谈复杂度&#34;&gt;谈谈复杂度&lt;/h3&gt;

&lt;p&gt;程序员在意实现的复杂度，用户在意界面或接口的复杂度，第三个标准是代码总行数。&lt;/p&gt;

&lt;p&gt;接口复杂度和实现复杂度需要折衷。&lt;/p&gt;

&lt;p&gt;旧学派UNIX唯一的框架就是重定向、管道和shell，而Emacs将非常多的文本缓冲区和援助进程同文件系统统一在一起，大大超越shell框架。&lt;/p&gt;

&lt;p&gt;选择需要管理的上下文环境，并且按照边界所允许的最小化方式构建程序。只有实证其他方法行不通时才编写大程序。&lt;/p&gt;

&lt;h2 id=&#34;语言-c还是非c&#34;&gt;语言：C还是非C&lt;/h2&gt;

&lt;p&gt;C的内存管理是复杂性和错误的深渊。&lt;/p&gt;

&lt;p&gt;真实世界中的程序往往受I/O、网络等的影响远大于CPU的影响。&lt;/p&gt;

&lt;p&gt;shell即使一种最早的解释型语言，高级shell编程可以混合各个语言。&lt;/p&gt;

&lt;p&gt;C语言资源效率接近机器语言，但是编程是资源管理的炼狱。&lt;/p&gt;

&lt;p&gt;C++最佳之处是编译效率以及面向对象和泛型编程的结合，最糟之处是它太过怪异复杂，其设计者承认他不指望任何一个程序员能够完全掌握C++。&lt;/p&gt;

&lt;p&gt;shell最佳之处在书写小型程序自然快捷，不用安装，但是不适合大型程序，并且不好移植。&lt;/p&gt;

&lt;p&gt;Perl最佳之处是作为加强shell的强力胶合程序，但是Perl有些部分很丑陋。&lt;/p&gt;

&lt;p&gt;Python清晰易读，易学易用，容易和C结合，但是效率相对低下。&lt;/p&gt;

&lt;p&gt;Java移植性好，效率较高，面向对象，但是爹不好。。。&lt;/p&gt;

&lt;h2 id=&#34;工具-开发的战术&#34;&gt;工具：开发的战术&lt;/h2&gt;

&lt;p&gt;讲解了各种UNIX开发工具，但是太过陈旧了。&lt;/p&gt;

&lt;h2 id=&#34;重用-论不要重新发明轮子&#34;&gt;重用：论不要重新发明轮子&lt;/h2&gt;

&lt;p&gt;透明性是重用的关键。&lt;/p&gt;

&lt;p&gt;开源后换工作也可以使用原来的代码。&lt;/p&gt;

&lt;p&gt;编写开源软件的人往往自己也使用，并且开源社区不会羞于抓bug。&lt;/p&gt;

&lt;h3 id=&#34;许可证问题&#34;&gt;许可证问题&lt;/h3&gt;

&lt;p&gt;OSD，OSI Cerified Open Source认证标志的法律定义，是最好的自由软件定义。所有标准许可证都满足他。&lt;/p&gt;

&lt;p&gt;MIT，BSD，GPL，MPL等等。&lt;/p&gt;

&lt;h2 id=&#34;可移植性-软件可移植性与遵循标准&#34;&gt;可移植性：软件可移植性与遵循标准&lt;/h2&gt;

&lt;h2 id=&#34;文档-向网络世界阐释代码&#34;&gt;文档：向网络世界阐释代码&lt;/h2&gt;

&lt;h2 id=&#34;开放源码-在unix新社区中编程&#34;&gt;开放源码：在UNIX新社区中编程&lt;/h2&gt;

&lt;p&gt;开发源码的规则很简单：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;源码公开&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;尽早发布，经常发布&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;给贡献以表扬&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;开源开发利用散布在互联网上，而且主要通过email和网络文档交流的大型程序员团队。一般有核心开发者或核心开发组来指导项目。&lt;/p&gt;

&lt;p&gt;代码质量很难判断，开发者通常通过提交质量来评估补丁。&lt;/p&gt;

&lt;h2 id=&#34;未来-危机与机遇&#34;&gt;未来：危机与机遇&lt;/h2&gt;

&lt;h3 id=&#34;plan-9-未来之路&#34;&gt;PLAN 9， 未来之路&lt;/h3&gt;

&lt;p&gt;所有挂载的文件服务器都具备相同的类文件系统接口。&lt;/p&gt;

&lt;p&gt;PLAN 9 失败了，说明更优秀方案的最危险敌人，就是一个现存的足够优秀的架构。&lt;/p&gt;

&lt;h3 id=&#34;unix设计中的问题&#34;&gt;UNIX设计中的问题&lt;/h3&gt;

&lt;p&gt;UNIX文件就是一大袋字节。&lt;/p&gt;

&lt;p&gt;UNIX对GUI支持孱弱。&lt;/p&gt;

&lt;p&gt;文件删除不可撤销。&lt;/p&gt;

&lt;p&gt;UNIX假定文件系统是静态的。Linux改进了这一点，具有文件和目录更改通知功能。&lt;/p&gt;

&lt;p&gt;作业控制设计拙劣。&lt;/p&gt;

&lt;p&gt;UNIX API没有使用异常。&lt;/p&gt;

&lt;h3 id=&#34;unix环境问题&#34;&gt;UNIX环境问题&lt;/h3&gt;

&lt;h3 id=&#34;unix文化问题&#34;&gt;UNIX文化问题&lt;/h3&gt;

&lt;h3 id=&#34;信任的理由&#34;&gt;信任的理由&lt;/h3&gt;

&lt;p&gt;迄今为止，打赌UNIX玩家会输的人总是聪明一时糊涂一世。我们能赢————只要我们想赢。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Python解析XML与生成迭代器</title>
      <link>https://dailydreamer.me/post/2015-06-23-python-yeild-and-parse-xml/</link>
      <pubDate>Tue, 23 Jun 2015 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/post/2015-06-23-python-yeild-and-parse-xml/</guid>
      <description>

&lt;p&gt;这次来看看Python解析XML与生成迭代器。&lt;/p&gt;

&lt;h2 id=&#34;迭代器&#34;&gt;迭代器&lt;/h2&gt;

&lt;p&gt;使用yield操作符可以使一个函数变成迭代器。如下一段测试代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;def genTest(n):
  print 1
  print 2
  for i in range(3,n+1):
    yield i
  print n+1
  print n+2

if __name__ == &#39;__main__&#39;:
  for i in genTest(5):
    print i
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;输出如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;1
2
3
4
5
6
7
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看出第一次调用genTest()时执行了1,2位置的代码。
之后yield将i返回给caller的i，然后再次调用时继续从genTest上次yield之后的代码执行，直至最后return停止，迭代结束。&lt;/p&gt;

&lt;h2 id=&#34;python解析xml&#34;&gt;Python解析XML&lt;/h2&gt;

&lt;p&gt;Python解析XML有许多种方法，它们各有特色。&lt;/p&gt;

&lt;h3 id=&#34;elementtree&#34;&gt;ElementTree&lt;/h3&gt;

&lt;p&gt;&lt;a href=&#34;https://docs.python.org/2/library/xml.etree.elementtree.html&#34;&gt;ElementTree&lt;/a&gt;是python xml解析的一种轻量级实现。
它将XMl文件读取到内存中以一棵树的形式存储。
它速度快且方便使用，但是不能读取不规范的XMl文件，并且会一次将XML文件解析入内存。
因此适合解析一些小型的XML文件。
cElementTree是它的一个C优化过的版本。&lt;/p&gt;

&lt;p&gt;示例代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;def readXMLET(filename):
  try:
    import xml.etree.cElementTree as ET
  except ImportError:
    import xml.etree.ElementTree as ET
  tree = ET.ElementTree(file=filename)
  print &#39;read finish!&#39;
  root = tree.getroot()
  for child in root:
    yield child.tag, child.attrib
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;beautifulsoup-parser&#34;&gt;BeautifulSoup Parser&lt;/h3&gt;

&lt;p&gt;刚提到ElementTree不能读取不规范的XML，&lt;a href=&#34;http://lxml.de/elementsoup.html&#34;&gt;BeautifulSoup Parser&lt;/a&gt;则可以，它试图修复XML中的不规范成分。
但是由于使用了正则表达式，相对的它的效率会低于ElementTree。&lt;/p&gt;

&lt;p&gt;示例代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;def readXMLlxml(filename):
  from lxml.html import soupparser

  tree = soupparser.parse(filename)
  root = tree.getroot()
  for child in root:
    yield child.tag, child.attrib
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;sax&#34;&gt;SAX&lt;/h3&gt;

&lt;p&gt;前面两种方法都是将XML一次以一棵树的形式读入内存中。
若是XML文件较大的话这种方式会非常慢且消耗内存。
&lt;a href=&#34;https://docs.python.org/2/library/xml.sax.html&#34;&gt;SAX&lt;/a&gt;则是以一种异步的方式处理它遇到的XML标签，而不是将其一次全部解析，因此比较适合体积很大的XML文件。
但是它不会记得之前处理过的标签算是一个缺点。&lt;/p&gt;

&lt;p&gt;你需要继承xml.sax.ContentHandler类，然后在解析的时候将这个类的实例传入即可。&lt;/p&gt;

&lt;p&gt;这个类有如下方法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;characters(content)方法：调用时机为从行开始，遇到标签之前，存在字符，content的值为这些字符串；从一个标签，遇到下一个标签之前， 存在字符，content的值为这些字符串；从一个标签，遇到行结束符之前，存在字符，content的值为这些字符串。标签可以是开始标签，也可以是结束标签。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;startDocument()方法：文档启动的时候调用。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;endDocument()方法：解析器到达文档结尾时调用。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;startElement(name, attrs)方法：遇到XML开始标签时调用，name是标签的名字，attrs是标签的属性值字典。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;endElement(name)方法：遇到XML结束标签时调用。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;示例代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;class resHandler(xml.sax.ContentHandler):
  def __init__(self):
    self.count = 0

  def startElement(self, tag, attrib):
    if tag == &#39;doc&#39;:
      self.count += 1
      if self.count % 1000 == 0:
        print self.count
      doc = {
        TAG:tag,
        TITLE:attrib[TITLE],
        ANCHOR:attrib[ANCHOR],
        H1:attrib[H1],
        PATH:attrib[PATH],
        PAGERANK:attrib[PAGERANK]
      }
      print doc

def readXMLSAX(filename):
  parser = xml.sax.make_parser()
  parser.setContentHandler(resHandler())
  parser.parse(filename)
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>ElasticSearch搜索配置（2）</title>
      <link>https://dailydreamer.me/post/2015-06-22-elasticsearch-config-2/</link>
      <pubDate>Mon, 22 Jun 2015 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/post/2015-06-22-elasticsearch-config-2/</guid>
      <description>

&lt;p&gt;这次再来说说ElasticSearch的其他一些特性。&lt;/p&gt;

&lt;h2 id=&#34;bulk&#34;&gt;Bulk&lt;/h2&gt;

&lt;p&gt;使用Index进行索引是一次索引一条doc，而bulk提供了批量索引的功能，能够显著的减少索引时间。
经过实际测试，对于1个100Mb约20K条doc，向远程服务器单节点发起索引的完成时间对比如下表。&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;chunck_size&lt;/th&gt;
&lt;th align=&#34;center&#34;&gt;time/s&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;200&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;298.34&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;500&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;216.84&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;1000&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;169.64&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;2000&lt;/td&gt;
&lt;td align=&#34;center&#34;&gt;164.71&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;可以看出chunck_size在一个合适的区间时可以显著减少索引时间，而chunck_size的选取也和一个doc的大小有关。&lt;/p&gt;

&lt;p&gt;这里是&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html&#34;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;ElasticSearch的python API中对bulk进行了封装，有&lt;code&gt;helpers.streaming_bulk&lt;/code&gt;和&lt;code&gt;helpers.bulk&lt;/code&gt;两个方法，&lt;a href=&#34;https://elasticsearch-py.readthedocs.org/en/master/helpers.html?highlight=bulk#elasticsearch.helpers.bulk&#34;&gt;官方文档&lt;/a&gt;在这。大致使用方法如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;for success, fail in helpers.streaming_bulk(es, genDoc(filename), index=INDEX, doc_type=DOCTYPE, chunk_size=1000):
    print &#39;success: &#39;, success
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;success, fail = helpers.bulk(es, genDoc(filename), index=INDEX, doc_type=DOCTYPE, chunk_size=1000)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中geDoc()是一个迭代器。
这两个方法的区别在于bulk调用了streaming_bulk并将信息一起返回。&lt;/p&gt;

&lt;h2 id=&#34;拼音搜索&#34;&gt;拼音搜索&lt;/h2&gt;

&lt;p&gt;对于中文内容较多的索引，如果能够使用拼音搜索会十分方便。
ElasticSearch有插件&lt;a href=&#34;https://github.com/medcl/elasticsearch-analysis-pinyin&#34;&gt;elasticsearch-analysis-pinyin&lt;/a&gt;可以实现这个功能。
它可以将中文转化为拼音字母，在建立索引的时候就可以在倒排列表中使对应的拼音字母关联到包含中文的Doc上。&lt;/p&gt;

&lt;p&gt;为了将拼音搜索的索引和IK分词的索引结合，需要用到另一个插件&lt;a href=&#34;https://github.com/yakaz/elasticsearch-analysis-combo/&#34;&gt;elasticsearch-analysis-combo&lt;/a&gt;。
它可以将两个Analyzer的结果合并起来得到一个新的Analyzer。&lt;/p&gt;

&lt;p&gt;基本的配置如下。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;index:
  analysis:
    analyzer:
      ik:
          alias: [news_analyzer_ik,ik_analyzer]
          type: org.elasticsearch.index.analysis.IkAnalyzerProvider
      ik_max_word:
          type: ik
          use_smart: false
      ik_smart:
          type: ik
          use_smart: true
      pinyin:
        type: custom
        tokenizer: standard
        filter:
         - standard 
         - pinyin_filter
         - lowercase         
      combo:
        type: combo
        sub_analyzers: 
         - ik
         - pinyin
    filter:
      pinyin_filter : 
        type : pinyin
        first_letter : none
        padding_char : &#39;&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;先使用pinyin插件定义一个pinyin filter， &lt;code&gt;first_letter&lt;/code&gt;属性看是否得到拼音首字母缩写，&lt;code&gt;padding_char&lt;/code&gt;属性确定首字母缩写和全拼音的连接方式。
然后定义一个custom的pinyin analyzer。tokenizer使用standard，将所有汉字词语分成单个字，filter先通过standard初步过滤，然后使用pinyin filter转成单个字的拼音，最后使用lowercase统一小写。&lt;/p&gt;

&lt;p&gt;效果如下：&lt;/p&gt;

&lt;p&gt;输入命令&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;curl -XGET &#39;http://localhost:9200/school_search_index/_analyze?analyzer=pinyin&amp;amp;pretty&#39; -d &#39;清华大学&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;得到结果&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;{
  &amp;quot;tokens&amp;quot; : [ {
    &amp;quot;token&amp;quot; : &amp;quot;qing&amp;quot;,
    &amp;quot;start_offset&amp;quot; : 0,
    &amp;quot;end_offset&amp;quot; : 1,
    &amp;quot;type&amp;quot; : &amp;quot;&amp;lt;IDEOGRAPHIC&amp;gt;&amp;quot;,
    &amp;quot;position&amp;quot; : 1
  }, {
    &amp;quot;token&amp;quot; : &amp;quot;hua&amp;quot;,
    &amp;quot;start_offset&amp;quot; : 1,
    &amp;quot;end_offset&amp;quot; : 2,
    &amp;quot;type&amp;quot; : &amp;quot;&amp;lt;IDEOGRAPHIC&amp;gt;&amp;quot;,
    &amp;quot;position&amp;quot; : 2
  }, {
    &amp;quot;token&amp;quot; : &amp;quot;da&amp;quot;,
    &amp;quot;start_offset&amp;quot; : 2,
    &amp;quot;end_offset&amp;quot; : 3,
    &amp;quot;type&amp;quot; : &amp;quot;&amp;lt;IDEOGRAPHIC&amp;gt;&amp;quot;,
    &amp;quot;position&amp;quot; : 3
  }, {
    &amp;quot;token&amp;quot; : &amp;quot;xue&amp;quot;,
    &amp;quot;start_offset&amp;quot; : 3,
    &amp;quot;end_offset&amp;quot; : 4,
    &amp;quot;type&amp;quot; : &amp;quot;&amp;lt;IDEOGRAPHIC&amp;gt;&amp;quot;,
    &amp;quot;position&amp;quot; : 4
  } ]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最后使用combo analyzer将两个analyzer合并。&lt;/p&gt;

&lt;h2 id=&#34;自动补全&#34;&gt;自动补全&lt;/h2&gt;

&lt;p&gt;搜索引擎的自动补全有两种类型。
一种是基于你过去或者是其他人的热门的搜索历史进行补全，另一种是基于语言模型进行补全。&lt;/p&gt;

&lt;p&gt;对于第一种根据搜索历史的补全，适用与拥有大量数据的搜索引擎。
在ElasticSearch中可以使用&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/current/search-suggesters-completion.html&#34;&gt;Completion Suggester&lt;/a&gt;实现。
由于不适用与用户数据较少的搜索引擎，便不细说，可以参考&lt;a href=&#34;http://blog.qbox.io/quick-and-dirty-autocomplete-with-elasticsearch-completion-suggest&#34;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;第二种基于语言模型的补全，可以使用类似于拼音搜索的实现方式，在建立索引的时候对一个单词string的所有substring都建立到包含该string的Doc的映射即可。
但是需要注意的是这样会显著增加索引的大小。&lt;/p&gt;

&lt;p&gt;在ElasticSearch中可以使用&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-ngram-tokenizer.html#analysis-ngram-tokenizer&#34;&gt;n-Gram Tokenizer&lt;/a&gt;或&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-ngram-tokenfilter.html&#34;&gt;n-Gram filter&lt;/a&gt;实现。
具体可以参考&lt;a href=&#34;http://jontai.me/blog/2013/02/adding-autocomplete-to-an-elasticsearch-search-application/&#34;&gt;这篇文章&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>ElasticSearch搜索配置（1）</title>
      <link>https://dailydreamer.me/post/2015-06-05-elasticsearch-config-1/</link>
      <pubDate>Fri, 05 Jun 2015 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/post/2015-06-05-elasticsearch-config-1/</guid>
      <description>

&lt;p&gt;最近在用ElasticSearch做一些搜索，来谈谈其中用到的一些特性。&lt;/p&gt;

&lt;p&gt;ElasticSearch是基于Lucene的分布式包装，其中每一个分片或一个副本都是一个Lucene实例。
ElasticSearch实现了很好的扩展性和冗余，自动负载均衡。可以通过Restful API与ElasticSearch集群交互。
我使用的是&lt;a href=&#34;https://elasticsearch-py.readthedocs.org/en/master/&#34;&gt;python API&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;可以参考&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/guide/master/index.html&#34;&gt;ElasticSearch权威指南&lt;/a&gt;，讲解非常清楚。&lt;/p&gt;

&lt;h2 id=&#34;建立索引&#34;&gt;建立索引&lt;/h2&gt;

&lt;p&gt;建立索引的时候可以使用mapping建立对每个字段建立映射。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;mapping_body = {
    &#39;mappings&#39;:{
        &#39;tweet&#39;:{
            &amp;quot;properties&amp;quot;:{
                &#39;text&#39;:{&#39;type&#39;:&#39;string&#39;, &#39;index&#39;:&#39;analyzed&#39;, &#39;analyzer&#39;:&#39;ik_smart&#39;, &#39;similarity&#39;: &#39;BM25&#39;}
            }
        }
    }
}
es.indices.create(index=&#39;test-index&#39;, body=mapping_body)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面为&amp;rsquo;test-index&amp;rsquo;的索引中&amp;rsquo;tweet&amp;rsquo;的type中&amp;rsquo;text&amp;rsquo;字段建立映射。&lt;/p&gt;

&lt;p&gt;&amp;lsquo;index&amp;rsquo;设置为analyzed说明要先通过分析器，&amp;rsquo;analyzer&amp;rsquo;设置分析器为ik分词的智能粒度切分，默认为standard，不适合中文分词;&amp;lsquo;similarity&amp;rsquo;设置了相似度算法为BM25，默认为向量空间算法。&lt;/p&gt;

&lt;p&gt;具体可以看&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping.html&#34;&gt;文档&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&#34;查询&#34;&gt;查询&lt;/h2&gt;

&lt;p&gt;查询可以通过ID来检索，但是作为一个搜索引擎，ElasticSearch提供了一种基于JSON的&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html&#34;&gt;DSL查询格式&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;search_body = {
    &amp;quot;query&amp;quot;: {
        &amp;quot;multi_match&amp;quot;: {
            &amp;quot;query&amp;quot;:       &amp;quot;Hello世界&amp;quot;,
            &amp;quot;type&amp;quot;:        &amp;quot;cross_fields&amp;quot;, 
            &amp;quot;operator&amp;quot;:    &amp;quot;or&amp;quot;,
            &amp;quot;fields&amp;quot;:      [ &amp;quot;author&amp;quot;, &amp;quot;text^2&amp;quot; ]
        }
     },
    &#39;highlight&#39;:{
        &#39;fields&#39;:{
            &#39;author&#39;:{},
            &#39;text&#39;:{}
        }
    }

}
res = es.search(index=&#39;test-index&#39;, doc_type=&#39;tweet&#39;, body=search_body)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;query&#34;&gt;Query&lt;/h3&gt;

&lt;p&gt;上面的示例中使用了&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html&#34;&gt;multi match query&lt;/a&gt;来进行多字段查询，multi match query对fields中的每个field进行query查询。&lt;/p&gt;

&lt;p&gt;&amp;lsquo;operator&amp;rsquo;定义了对查询结果进行的操作，&amp;rsquo;or&amp;rsquo;代表取并集。&lt;/p&gt;

&lt;p&gt;fields中的&lt;code&gt;^&lt;/code&gt;代表对该字段进行boost，之后的值为浮点数，小于1表示减轻权重，否则加大权重。&lt;/p&gt;

&lt;p&gt;&amp;lsquo;type&amp;rsquo;中的类型和适用场景见下表&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Type&lt;/th&gt;
&lt;th&gt;Explain&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;best_fields&lt;/td&gt;
&lt;td&gt;(default) Finds documents which match any field, but uses the &lt;code&gt;_score&lt;/code&gt; from the best field. See best_fields.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;most_fields&lt;/td&gt;
&lt;td&gt;Finds documents which match any field and combines the &lt;code&gt;_score&lt;/code&gt; from each field. See most_fields.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;cross_fields&lt;/td&gt;
&lt;td&gt;Treats fields with the same analyzer as though they were one big field. Looks for each word in any field. See cross_fields.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;phrase&lt;/td&gt;
&lt;td&gt;Runs a match_phrase query on each field and combines the &lt;code&gt;_score&lt;/code&gt; from each field. See phrase and phrase_prefix.&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;phrase_prefix&lt;/td&gt;
&lt;td&gt;Runs a match_phrase_prefix query on each field and combines the &lt;code&gt;_score&lt;/code&gt; from each field. See phrase and phrase_prefix.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;code&gt;cross_fields&lt;/code&gt;是将所有字段放在一起搜索，跟对&lt;code&gt;_all&lt;/code&gt;进行query相比它可以附加权重，但是效率略微低一点。&lt;/p&gt;

&lt;p&gt;更加详细的type的使用情景可以看权威指南的&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/guide/current/_single_query_string.html&#34;&gt;Know Your Data&lt;/a&gt;一节。&lt;/p&gt;

&lt;h3 id=&#34;function-score-query和script&#34;&gt;Function Score query和script&lt;/h3&gt;

&lt;p&gt;如果需要吧离线算好的pagerank和在线查询的得分结合起来给结果排序，可以使用强大的&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-function-score-query.html&#34;&gt;Function Score query&lt;/a&gt;和&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-scripting.html#_indexed_scripts&#34;&gt;script&lt;/a&gt;来做到这一点。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-py&#34;&gt;&amp;quot;query&amp;quot;:{
    &amp;quot;function_score&amp;quot;: {
        &amp;quot;boost_mode&amp;quot;: &amp;quot;replace&amp;quot;,
        &amp;quot;query&amp;quot;: {
            &amp;quot;multi_match&amp;quot;: {
                &amp;quot;query&amp;quot;:query,
                &amp;quot;type&amp;quot;:&amp;quot;cross_fields&amp;quot;, 
                &amp;quot;operator&amp;quot;:&amp;quot;or&amp;quot;,
                &amp;quot;fields&amp;quot;:SEACHFIELDS
            }
         },
        &amp;quot;script_score&amp;quot;: {
            &amp;quot;lang&amp;quot;:&amp;quot;groovy&amp;quot;,
            &amp;quot;params&amp;quot;: {
                &amp;quot;pagerankField&amp;quot;: PAGERANK, 
                &amp;quot;pagerankW&amp;quot;: PAGERANKW, 
                &amp;quot;scoreW&amp;quot;: 1 - PAGERANKW
            },
            &amp;quot;script_file&amp;quot;: &amp;quot;school-search&amp;quot;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;使用&lt;code&gt;function_score&lt;/code&gt;将原query包裹起来，在&lt;code&gt;script_score&lt;/code&gt;中，&lt;code&gt;lang&lt;/code&gt;设置脚本语言，默认为groovy;&lt;code&gt;params&lt;/code&gt;设置脚本参数，&lt;code&gt;script_file&lt;/code&gt;指定脚本文件，脚本文件保存在&lt;code&gt;./config/scripts/&lt;/code&gt;下，不用写出后缀名，&lt;code&gt;config/scripts/group1/group2/test.py&lt;/code&gt;应该命名为&lt;code&gt;group1_group2_test&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;脚本内容类似下面&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-groovy&#34;&gt;_score * scoreW + doc[pagerankField].value * pagerankW
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;其中&lt;code&gt;_score&lt;/code&gt;是query得分，&lt;code&gt;doc[field_name]&lt;/code&gt;可以获得当前doc的field，也可在其中使用&lt;code&gt;parms&lt;/code&gt;中指定的参数。&lt;/p&gt;

&lt;p&gt;还有一种使用脚本的方法是将其索引在一个特殊文件&lt;code&gt;.scripts&lt;/code&gt;中，但是由于这个功能曾经爆出漏洞，而且性能不如上面的方法，现在已经默认关闭，在此不再讨论。&lt;/p&gt;

&lt;h3 id=&#34;highlight&#34;&gt;Highlight&lt;/h3&gt;

&lt;p&gt;使用highlight可以在返回结果的&amp;rsquo;highlight&amp;rsquo;字段中对匹配词进行高亮，&amp;rsquo;fields&amp;rsquo;设置要高亮的field，还可以对高亮格式进行设置，默认为&lt;em&gt;&lt;/em&gt;。详细可以看&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-highlighting.html#_highlight_query&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&#34;filter&#34;&gt;Filter&lt;/h3&gt;

&lt;p&gt;filter更像是数据库中的一些操作，不会返回_score值，只有满足条件才会被返回，但是相比query效率更高。详细可以看&lt;a href=&#34;https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-filters.html&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;有了这些基本能够满足简单的搜索需要了。&lt;/p&gt;

&lt;p&gt;找到了一个翻译了一部分权威指南的Blog，记录在&lt;a href=&#34;http://blog.csdn.net/dm_vincent/article/details/41820537&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>程序员修炼之道</title>
      <link>https://dailydreamer.me/post/2015-06-04-a-pragmatic-programmer/</link>
      <pubDate>Thu, 04 Jun 2015 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/post/2015-06-04-a-pragmatic-programmer/</guid>
      <description>

&lt;p&gt;这本书出版有些年头了，虽然其中的例子有些老旧，但是有些思想和哲学永远不会过时。&lt;/p&gt;

&lt;h2 id=&#34;注重实效的哲学&#34;&gt;注重实效的哲学&lt;/h2&gt;

&lt;p&gt;负责，提供各种选择，不找蹩脚的借口。&lt;/p&gt;

&lt;p&gt;避免软件腐烂，破窗效应，不要容忍破窗户。&lt;/p&gt;

&lt;p&gt;启动杂役，做变化的催化剂。&lt;/p&gt;

&lt;p&gt;不要被温水煮青蛙，留意大图景。&lt;/p&gt;

&lt;p&gt;让用户参与权衡，使质量成为需求问题。&lt;/p&gt;

&lt;p&gt;像管理金融资产一样管理知识资产。定期为你的知识资产投资。&lt;/p&gt;

&lt;p&gt;不要搁置问题。&lt;/p&gt;

&lt;p&gt;批判的分析你读到的和听到的。&lt;/p&gt;

&lt;p&gt;注重交流，想清楚你要说什么，了解听众。&lt;/p&gt;

&lt;h2 id=&#34;注重实效的途径&#34;&gt;注重实效的途径&lt;/h2&gt;

&lt;h3 id=&#34;重复的危害&#34;&gt;重复的危害&lt;/h3&gt;

&lt;p&gt;系统中的每一项知识都必须具有单一、无歧义、权威的表示。Don&amp;rsquo;t Repeat Yourself！这不是你是否能记住的问题，而是何时忘记的问题。&lt;/p&gt;

&lt;p&gt;强加的重复：&lt;/p&gt;

&lt;p&gt;客户端服务器端不同语言：可以根据元数据在Build时生成不同语言的类定义及结构。&lt;/p&gt;

&lt;p&gt;根据需求文档自动生成测试。&lt;/p&gt;

&lt;p&gt;无意的重复：&lt;/p&gt;

&lt;p&gt;需要缓存时可能会破坏DRY原则，但是应该在类内部解决，不要将其暴露给外界。&lt;/p&gt;

&lt;h3 id=&#34;正交性&#34;&gt;正交性&lt;/h3&gt;

&lt;p&gt;消除无关事物之间的影响。&lt;/p&gt;

&lt;h3 id=&#34;可撤销性&#34;&gt;可撤销性&lt;/h3&gt;

&lt;p&gt;不存在最终决策，采用灵活的架构。&lt;/p&gt;

&lt;h3 id=&#34;曳光弹&#34;&gt;曳光弹&lt;/h3&gt;

&lt;p&gt;用曳光弹找到目标，给出可展示的项目骨架，它可以即时的反馈。&lt;/p&gt;

&lt;h3 id=&#34;原型与便笺&#34;&gt;原型与便笺&lt;/h3&gt;

&lt;p&gt;为了学习而制作原型。原型甚至可以不用编码，他需要确定各个组件的责任和是否解耦。&lt;/p&gt;

&lt;h2 id=&#34;基本工具&#34;&gt;基本工具&lt;/h2&gt;

&lt;p&gt;用纯文本保存知识。它不会过时，更易测试。&lt;/p&gt;

&lt;p&gt;要修正问题，而不是发出指责。&lt;/p&gt;

&lt;p&gt;再现bug，使数据可视化。&lt;/p&gt;

&lt;p&gt;向别人讲述你的代码要做什么时可能会帮助你理清思路。&lt;/p&gt;

&lt;p&gt;不要假定，要证明。&lt;/p&gt;

&lt;h2 id=&#34;注重实效的偏执&#34;&gt;注重实效的偏执&lt;/h2&gt;

&lt;p&gt;你不可能写出完美的软件。&lt;/p&gt;

&lt;h3 id=&#34;dbc-按合约设计&#34;&gt;DBC 按合约设计&lt;/h3&gt;

&lt;p&gt;前条件，后条件，类不变项。&lt;/p&gt;

&lt;h3 id=&#34;死程序不说谎&#34;&gt;死程序不说谎&lt;/h3&gt;

&lt;p&gt;早崩溃，要崩溃不要破坏。&lt;/p&gt;

&lt;h3 id=&#34;断言式编程&#34;&gt;断言式编程&lt;/h3&gt;

&lt;p&gt;如果他不可能发生，用断言确保。&lt;/p&gt;

&lt;h2 id=&#34;弯曲-或折断&#34;&gt;弯曲，或折断&lt;/h2&gt;

&lt;p&gt;使模块之间的耦合减至最小。&lt;/p&gt;

&lt;p&gt;要配置，不要集成。&lt;/p&gt;

&lt;p&gt;将抽象放进代码，将细节放进元数据。&lt;/p&gt;

&lt;p&gt;总是为并发进行设计。&lt;/p&gt;

&lt;p&gt;使模型与视图分离。&lt;/p&gt;

&lt;h2 id=&#34;当你编码时&#34;&gt;当你编码时&lt;/h2&gt;

&lt;p&gt;不要靠巧合编程。&lt;/p&gt;

&lt;p&gt;为你的假定建立文档。&lt;/p&gt;

&lt;p&gt;早重构，常重构。这是一种痛苦管理。经常进行短小的重构之后测试。&lt;/p&gt;

&lt;p&gt;测试驱动的设计。测试你的软件，否则你的用户就得测试。&lt;/p&gt;

&lt;p&gt;与用户一同工作，以像用户一样思考。&lt;/p&gt;

&lt;p&gt;抽象比细节获得更长久。&lt;/p&gt;

&lt;p&gt;不要在盒子外面思考，要找到盒子，即真正的约束。亚历山大大帝用剑劈开了弗里吉亚国王戈尔系的号称解不开的结。&lt;/p&gt;

&lt;p&gt;有些事情去做胜于描述，比如试着描述一下你系鞋带的过程。不要一开始编写太过详尽的规范。它和编码总是交替进行。&lt;/p&gt;

&lt;p&gt;不要做形式方法的奴隶，有时原型展示比UML图更有说服力。昂贵的工具不一定能制作出更好的设计。&lt;/p&gt;

&lt;h2 id=&#34;注重实效的项目&#34;&gt;注重实效的项目&lt;/h2&gt;

&lt;p&gt;不要使用手工流程。&lt;/p&gt;

&lt;p&gt;早测试，常测试，自动测试。&lt;/p&gt;

&lt;p&gt;温和的超出用户的期望。与用户交流期望。&lt;/p&gt;

&lt;p&gt;在你的作品上签名。这是责任和荣耀的表现。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>在AWS上配置ElasticSearch</title>
      <link>https://dailydreamer.me/post/2015-06-02-config-elasticsearch-on-aws/</link>
      <pubDate>Tue, 02 Jun 2015 20:00:00 +0800</pubDate>
      
      <guid>https://dailydreamer.me/post/2015-06-02-config-elasticsearch-on-aws/</guid>
      <description>

&lt;p&gt;最近在AWS EC2上部署了ElasticSearch，感觉AWS的文档详细但稍显凌乱，在这里总结一下步骤。&lt;/p&gt;

&lt;p&gt;首先注册AWS。注意你需要一张支持外币支付的信用卡。&lt;/p&gt;

&lt;p&gt;然后创建IAM用户，并配置其权限和密钥对。
可按照&lt;a href=&#34;http://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/get-set-up-for-amazon-ec2.html&#34;&gt;文档&lt;/a&gt;中的步骤来。
注意为了使elasticsearch节点启动后能够自动发现别的节点，你可能需要在这一步为该用户而外设置read-only权限。&lt;/p&gt;

&lt;p&gt;之后有两种方案，可以直接部署在&lt;a href=&#34;http://aws.amazon.com/cn/ec2/&#34;&gt;EC2&lt;/a&gt;上，价格便宜量又足。
也可以部署在&lt;a href=&#34;http://aws.amazon.com/cn/elasticmapreduce/&#34;&gt;EMR&lt;/a&gt;上，获得Haddop的集群管理能力，方便扩展以及将来部署其它基于Haddop的程序。但是注意使用EMR除了支付EMR的计费还要支付其使用的EC2及S3等的计费。&lt;/p&gt;

&lt;h2 id=&#34;部署在ec2上&#34;&gt;部署在EC2上&lt;/h2&gt;

&lt;p&gt;进入EC2控制面板启动实例。
如果你希望数据在EC2实例关闭后不丢失需要为其配置挂载EBS卷并将其存储至EBS中，详细见&lt;a href=&#34;http://docs.aws.amazon.com/zh_cn/AWSEC2/latest/UserGuide/ebs-using-volumes.html&#34;&gt;文档&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;注意EBS卷最好在home/ec2-user/下新建目录挂载，上次我挂载在home/ec2-user/下结果不知道.ssh是存在那里的，然后就连接不上了。。。
挂载完EBS卷后需要更改其权限使得普通用户可以读写文件。
&lt;code&gt;sudo chmod 777 ./ -R&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;之后为其配置EIP来避免每次重启实例后IP地址改变。
EIP是一个固定的共有IP，将其和一个EC2实例的私有IP绑定即可。
这样也方便切换实例而IP不变。&lt;/p&gt;

&lt;p&gt;最后即可ssh连接到EC2上然后安装ElasticSearch了。&lt;/p&gt;

&lt;p&gt;安装好ElasticSearch之后还需安装&lt;a href=&#34;https://github.com/elastic/elasticsearch-cloud-aws&#34;&gt;elasticsearch-cloud-aws插件&lt;/a&gt;并配置才能实现自动Discovery。
大致的配置如&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yml&#34;&gt;# AWS discovery
cloud.aws.access_key: KEY
cloud.aws.secret_key: KEY

plugin.mandatory: cloud-aws
discovery.type: ec2
discovery.zen.ping.multicast.enabled: false
discovery.ec2.groups: &amp;quot;elasticsearch&amp;quot;

discovery.ec2.availability_zones: &amp;quot;ap-northeast-1a&amp;quot;
cloud.aws.region: &amp;quot;ap-northeast-1&amp;quot;

discovery.ec2.host_type: &amp;quot;public_ip&amp;quot;
network.publish_host: [PUBLIC_IP]

discovery.ec2.ping_timeout: &amp;quot;30s&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;discovery.ec2.groups是你的EC2集群所在的安全组，注意用这种方式的设置会将必须该安全组中所有节点都启动ElasticSearch服务才行，否则会一直等待。
如果不想这样可以使用Tag设置。&lt;/p&gt;

&lt;p&gt;discovery.ec2.availability_zones一定要写对，否则节点会无法互相发现，不知道可以看EC2控制面版中有写。&lt;/p&gt;

&lt;p&gt;network.publish_host是该节点的公网IP，可使用绑定的弹性IP。&lt;/p&gt;

&lt;p&gt;更加详细的设置可以看&lt;a href=&#34;http://www.markbetz.net/2014/03/18/elasticsearch-discovery-in-ec2/&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;有关部署的更加详细的步骤可以参考&lt;a href=&#34;http://pavelpolyakov.com/2014/08/13/elasticsearch-cluster-on-aws-part-1-preparing-environment/&#34;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;注意如果弹性IP更换了绑定的实例之后要ssh之前需要将原来保存在本地的host_key删除，使用命令&lt;code&gt;ssh-keygen -R hostname&lt;/code&gt;,否则会报Host key verification failed。&lt;/p&gt;

&lt;h2 id=&#34;部署在emr上&#34;&gt;部署在EMR上&lt;/h2&gt;

&lt;p&gt;安装AWS CLI。
可按照&lt;a href=&#34;http://docs.aws.amazon.com/zh_cn/cli/latest/userguide/cli-chap-welcome.html&#34;&gt;文档&lt;/a&gt;安装并配置。&lt;/p&gt;

&lt;p&gt;然后直接使用Amazon EMR的&lt;a href=&#34;https://github.com/awslabs/emr-bootstrap-actions/tree/master/elasticsearch&#34;&gt;bootstrp action脚本&lt;/a&gt;即可。
这个仓库中还有其它基于Hadooop的软件的启动脚本，如spark，cascading等。&lt;/p&gt;

&lt;p&gt;输入命令(相关参数可自行配置)&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;aws emr create-cluster \
--ec2-attributes KeyName=&amp;quot;&amp;lt;YOUR_EC2_KEYNAME&amp;gt;&amp;quot; \
--log-uri=&amp;quot;&amp;lt;YOUR_LOGGING_BUCKET&amp;gt;&amp;quot; \
--bootstrap-action \
  Name=&amp;quot;Install ElasticSearch&amp;quot;,Path=&amp;quot;s3://support.elasticmapreduce/bootstrap-actions/other/elasticsearch_install.rb&amp;quot; \
  Name=&amp;quot;Installkibanaginx&amp;quot;,Path=&amp;quot;s3://support.elasticmapreduce/bootstrap-actions/other/kibananginx_install.rb&amp;quot; \
  Name=&amp;quot;Installlogstash&amp;quot;,Path=&amp;quot;s3://support.elasticmapreduce/bootstrap-actions/other/logstash_install.rb&amp;quot; \
--ami-version=3.5.0 \
--instance-count=3 \
--instance-type=m1.medium \
--name=&amp;quot;TestElasticSearch&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;即可启动一个3节点的elasticsearch集群，并安装kibana和logstash。&lt;/p&gt;

&lt;p&gt;至此，ElasticSearch集群便部署完成了。Enjoy your search~&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>